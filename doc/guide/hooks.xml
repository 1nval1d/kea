<!--
 - Copyright (C) 2014-2018 Internet Systems Consortium, Inc. ("ISC")
 -
 - This Source Code Form is subject to the terms of the Mozilla Public
 - License, v. 2.0. If a copy of the MPL was not distributed with this
 - file, You can obtain one at http://mozilla.org/MPL/2.0/.
-->

<!-- Converted by db4-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0" xml:id="hooks-libraries">

    <title>Hooks Libraries</title>
    <section xml:id="hooks-libraries-introduction">
      <title>Introduction</title>
      <para>
      Although Kea offers a lot of flexibility, there may be cases where
      its behavior needs customization.  To accommodate this possibility,
      Kea includes the idea of "Hooks".  This feature lets Kea load one
      or more dynamically-linked libraries (known as "hooks libraries")
      and, at various points in its processing ("hook points"), call
      functions in them.  Those functions perform whatever custom
      processing is required.
      </para>
      <para>
        The hooks concept also allows keeping the core Kea code reasonably small
        by moving features that some, but not all users find useful to external
        libraries. People who don't need specific functionality simply don't
        load the libraries.
      </para>
      <para>
      Hooks libraries are attached to individual Kea processes, not to
      Kea as a whole.  This means (for example) that it is possible
      to associate one set of libraries with the DHCP4 server and a
      different set to the DHCP6 server.
      </para>
      <para>
      Another point to note is that it is possible for a process to
      load multiple libraries.  When processing reaches a hook point,
      Kea calls the hooks library functions attached to it.  If multiple
      libraries have attached a function to a given hook point, Kea calls
      all of them, in the order in which the libraries are specified in
      the configuration file. The order may be important: consult the
      documentation of the libraries to see if this is the case.
      </para>
      <para>
      The next section describes how to configure hooks libraries. If you
      are interested in writing your own hooks library, information can be
      found in the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://jenkins.isc.org/job/Fedora20_32_doxygen_doc/doxygen/">Kea
      Developer's Guide</link>.
      </para>

      <para>
        Note that some libraries are available under different licenses.
      </para>
      <para>
        Note that some libraries may require additional dependencies and/or
        compilation switches to be enabled, e.g. Radius library introduced in
        Kea 1.4 requires FreeRadius-client library to be present. If
        --with-free-radius option is not specified, the Radius library will not
        be built.
      </para>
    </section> <!-- end Introduction -->
    <section>
      <title>Configuring Hooks Libraries</title>
      <para>
      The hooks libraries for a given process are configured using the
      <command>hooks-libraries</command> keyword in the
      configuration for that process. (Note that
      the word "hooks" is plural).  The value of the keyword
      is an array of map structures, each structure corresponding to a hooks
      library.  For example, to set up two hooks libraries for the DHCPv4
      server, the configuration would be:
<screen>
<userinput>"Dhcp4": {
    :
    "hooks-libraries": [
        {
            "library": "/opt/charging.so"
        },
        {
            "library": "/opt/local/notification.so",
            "parameters": {
                "mail": "spam@example.com",
                "floor": 13,
                "debug": false,
                "users": [ "alice", "bob", "charlie" ],
                "languages": {
                    "french": "bonjour",
                    "klingon": "yl'el"
                }
            }
        }
    ]
    :
}</userinput>
</screen>
      </para>

      <note><para>
        This is a change to the syntax used in Kea 0.9.2 and earlier, where
        hooks-libraries was a list of strings, each string being the name of
        a library.  The change was made in Kea 1.0 to facilitate the
        specification of library-specific parameters, a capability
        available in Kea 1.1.0 onwards. Libraries should allow a parameter
        entry where to put comments as it is done for many configuration
        scopes with comment and user context.
      </para></note>

        <note>
          <para>
          The library reloading behavior has changed in Kea 1.1. Libraries are
          reloaded, even if their list hasn't changed. Kea does that, because
          the parameters specified for the library (or the files those
          parameters point to) may have changed.
          </para>
        </note>

      <para>
        Libraries may have additional parameters. Those are not mandatory in the
        sense that there may be libraries that don't require them. However, for
        specific library there is often specific requirement for specify certain
        set of parameters. Please consult the documentation for your library
        for details. In the example above, the first library has no parameters.
        The second library has five parameters, specifying mail (string
        parameter), floor (integer parameter), debug (boolean parameter) and
        even lists (list of strings) and maps (containing strings). Nested
        parameters could be used if the library supports it. This topic is
        explained in detail in the Hooks Developer's Guide in the "Configuring
        Hooks Libraries" section.
      </para>

      <para>
      Notes:
        <itemizedlist mark="bullet">
          <listitem><para>
          The full path to each library should be given.
          </para></listitem>
          <listitem><para>
          As noted above, order may be important - consult the documentation for
          each library.
          </para></listitem>
          <listitem><para>
          An empty list has the same effect as omitting the
          <command>hooks-libraries</command> configuration element all together.
          </para>
          <note><para>
          There is one case where this is not true: if Kea
          is running with a configuration that contains a
          <command>hooks-libraries</command> item, and that item is
          removed and the configuration reloaded, the removal will be
          ignored and the libraries remain loaded.  As a workaround,
          instead of removing the <command>hooks-libraries</command>
          item, change it to an empty list.  This will be fixed in a
          future version of Kea.
          </para></note>
          </listitem>
        </itemizedlist>
      </para>
      <para>
      At the present time, only the kea-dhcp4 and kea-dhcp6 processes support
      hooks libraries.
      </para>
    </section>

    <section>
      <title>Available Hooks Libraries</title>
      <para>
      As described above, the hooks functionality provides a way to customize
      a Kea server without modifying the core code.  ISC has chosen to take
      advantage of this feature to provide functions that may only be useful
      to a subset of Kea users.  To this end ISC has created some hooks
      libraries; these discussed in the following sections.
      </para>

      <note><para>
      Some of these libraries will be available with the base code while others
      will be shared with organizations supporting development of Kea
      , possibly as a 'benefit' or 'thank you' for helping to sustain
      the larger Kea project. If you would like to get access to those
      libraries, please consider taking out a support contract: this includes
      professional support, advance security notifications, input into our
      roadmap planning, and many other benefits, while helping
      making Kea sustainable in the long term.
      </para></note>

      <para>Currently the following libraries are available or planned from ISC:

        <table frame="all" xml:id="hook-libs">
          <title>List of available hooks libraries</title>
          <tgroup cols="3">
          <colspec colname="name"/>
          <colspec colname="avail"/>
          <colspec colname="description"/>
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Availability</entry>
              <entry>Since</entry>
              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>user_chk</entry>
              <entry>Kea sources</entry>
              <entry>Kea 0.8</entry>
              <entry>Reads known users list from a file. Unknown users
              will be assigned a
              lease from the last subnet defined in the configuration file,
              e.g. to redirect them a captive portal. This demonstrates how an
              external source of information can be used to influence the Kea
              allocation engine. This hook is part of the Kea source code and is
              available in the src/hooks/dhcp/user_chk directory.</entry>
            </row>
            <row>
              <entry>Forensic Logging</entry>
              <entry>Support customers</entry>
              <entry>Kea 1.1.0</entry>
              <entry>This library provides hooks that record a detailed log of
              lease assignments and renewals into a set of log files. In many
              legal jurisdictions companies, especially ISPs, must record
              information about the addresses they have leased to DHCP
              clients. This library is designed to help with that
              requirement. If the information that it records is sufficient it
              may be used directly. If your jurisdiction requires that you save
              a different set of information, you may use it as a template or
              example and create your own custom logging hooks.</entry>
            </row>
            <row>
              <entry>Flexible Identifier</entry>
              <entry>Support customers</entry>
              <entry>Kea 1.2.0</entry>
              <entry>Kea software provides a way to handle host reservations
              that include addresses, prefixes, options, client classes and
              other features. The reservation can be based on hardware address,
              DUID, circuit-id or client-id in DHCPv4 and using hardware address
              or DUID in DHCPv6. However, there are sometimes scenarios where the
              reservation is more complex, e.g. uses other options that
              mentioned above, uses part of specific options or perhaps even a
              combination of several options and fields to uniquely identify a
              client. Those scenarios are addressed by the Flexible Identifiers
              hook application. It allows defining an expression, similar to
              the one used in client classification,
              e.g. substring(relay6[0].option[37],0,6). Each incoming packet is
              evaluated against that expression and its value is then searched
              in the reservations database.
              </entry>
            </row>
            <row>
              <entry>Host Commands</entry>
              <entry>Support customers</entry>
              <entry>Kea 1.2.0</entry>
              <entry>Kea provides a way to store host reservations in a
              database. In many larger deployments it is useful to be able to
              manage that information while the server is running. This library
              provides management commands for adding, querying and deleting
              host reservations in a safe way without restarting the server.
              In particular, it validates the parameters, so an attempt to
              insert incorrect data, e.g. add a host with conflicting identifier
              in the same subnet will be rejected. Those commands are
              exposed via command channel (JSON over unix sockets) and Control
              Agent (JSON over RESTful interface). Additional commands and
              capabilities related to host reservations will be added in the
              future.</entry>
            </row>
            <row>
              <entry>Subnet Commands</entry>
              <entry>Support customers</entry>
              <entry>Kea 1.3.0</entry>
              <entry>In deployments in which subnet configuration needs to
              be frequently updated, it is a hard requirement that such updates be
              performed without the need for a full DHCP server reconfiguration
              or restart. This hooks library allows for incremental changes
              to the subnet configuration such as: adding a subnet, removing
              a subnet. It also allows for listing all available subnets and
              fetching detailed information about a selected subnet. The
              commands exposed by this library do not affect other subnets
              or configuration parameters currently used by the server.
              </entry>
            </row>
            <row>
              <entry>High Availability</entry>
              <entry>Support customers</entry>
              <entry>Kea 1.4.0</entry>
              <entry>Minimizing a risk of DHCP service unavailability is achieved
              by setting up multiple instances of the DHCP servers in a network.
              Each server can serve selected group of clients in this network
              (load balancing) or all clients, if it detects that its partner has
              crashed or cannot be providing DHCP service for any other reason.
              It is also possible to designate one server to serve all DHCP clients,
              and leave another server as "standby". This server will activate its
              DHCP function when it detects that its partner is not available.
              Such cooperation between the DHCP servers requires that these
              servers constantly communicate with each other to send updates about
              allocated leases and to periodically test whether their partners are still
              operational. The "libdhcp_ha" library provides such functionality for
              Kea DHCP.
              </entry>
            </row>
            <row>
              <entry>Radius</entry>
              <entry>Support customers</entry>
              <entry>Kea 1.4.0</entry>
              <entry>The RADIUS Hook library allows Kea to interact with the
              RADIUS servers using access and accounting mechanisms. The access
              mechanism may be used for access control, assigning specific IPv4
              or IPv6 addresses reserved by RADIUS, dynamically assigning
              addresses from designated pools chosen by RADIUS or rejecting
              the client's messages altogether. The accounting mechanism allows
              RADIUS server to keep track of device activity over time.
              </entry>
            </row>
            <row>
              <entry>Host Cache</entry>
              <entry>Support customers</entry>
              <entry>Kea 1.4.0</entry>
              <entry>Some of the database backends, such as RADIUS, are
              considered slow and may take a long time to respond. Since Kea in
              general is synchronous, the backend performance directly affects
              the DHCP performance. To minimize the impact and improve
              performance, the Host Cache library provides a way to cache
              responses from other hosts. This includes negative caching,
              i.e. the ability to remember that there is no client information
              in the database.
              </entry>
            </row>
          </tbody>
          </tgroup>
          </table>

      </para>
      <para>
        ISC hopes to see more hooks libraries become available as time
        progresses, both developed internally and externally. Since
        this list may evolve dynamically, we decided to keep it on a
        wiki page, available at this link: <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://kea.isc.org/wiki/Hooks">http://kea.isc.org/wiki/Hooks</link>.
        If you are a developer or are aware of any hooks libraries not
        listed there, please send a note to the kea-users or kea-dev
        mailing lists and someone will update it.
      </para>
      <para>
        The libraries developed by ISC are described in detail in the following sections.
      </para>
      <section>
        <title>user_chk: Checking User Access</title>
        <para>
          The user_chk library is the first hooks library published by ISC. It
          attempts to serve several purposes:

          <itemizedlist>
            <listitem>
              <para>To assign "new" or "unregistered" users to a
              restricted subnet, while "known" or "registered" users are assigned
              to unrestricted subnets.</para>
            </listitem>
            <listitem>
              <para>To allow DHCP response options or vendor option
              values to be customized based upon user identity. </para>
            </listitem>
            <listitem>
              <para>To provide a real time record of the user registration
              activity which can be sampled by an external consumer.</para>
            </listitem>
            <listitem>
              <para> To serve as a demonstration of various capabilities
              possible using the hooks interface.</para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Once loaded, the library allows segregating incoming requests into
          known and unknown clients. For known clients, the packets are
          processed mostly as usual, except it is possible to override certain
          options being sent. That can be done on a per host basis. Clients
          that are not on the known hosts list will be treated as unknown and
          will be assigned to the last subnet defined in the configuration file.
        </para>

        <para>
          As an example of use, this behavior may be used to put unknown users into a
          separate subnet that leads to a walled garden, where they can only
          access a registration portal. Once they fill in necessary data, their
          details are added to the known clients file and they get a proper
          address after their device is restarted.
        </para>

        <note><para>This library was developed several years before the host
        reservation mechanism has become available. Currently host reservation is
        much more
        powerful and flexible, but nevertheless the user_chk capability to consult
        and external source of information about clients and alter Kea's
        behavior is useful and remains of educational value.
        </para></note>

        <para>
          The library reads the /tmp/user_chk_registry.txt file while being
          loaded and each time an incoming packet is processed. The file is expected
          to have each line contain a self-contained JSON snippet which must
          have the following two entries:

          <itemizedlist>
            <listitem><para><command>type</command>, whose value
            is "HW_ADDR" for IPv4 users or "DUID" for IPv6
            users</para></listitem>
            <listitem><para><command>id</command>, whose value is
            either the hardware address or the DUID from the request
            formatted as a string of hex digits, with or without
            ":" delimiters.</para></listitem>
          </itemizedlist>

and may have the zero or more of the following entries:

          <itemizedlist>
            <listitem><para><command>bootfile</command> whose value
            is the pathname of the desired file</para></listitem>
            <listitem><para><command>tftp_server</command> whose
            value is the hostname or IP address of the desired
            server</para></listitem>
          </itemizedlist>

          A sample user registry file is shown below:

<screen>{ "type" : "HW_ADDR", "id" : "0c:0e:0a:01:ff:04", "bootfile" : "/tmp/v4bootfile" }
{ "type" : "HW_ADDR", "id" : "0c:0e:0a:01:ff:06", "tftp_server" : "tftp.v4.example.com" }
{ "type" : "DUID", "id" : "00:01:00:01:19:ef:e6:3b:00:0c:01:02:03:04", "bootfile" : "/tmp/v6bootfile" }
{ "type" : "DUID", "id" : "00:01:00:01:19:ef:e6:3b:00:0c:01:02:03:06", "tftp_server" : "tftp.v6.example.com" }</screen>

        </para>

        <para>As with any other hooks libraries provided by ISC, internals of the
        user_chk code are well documented. You can take a look at the  <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://jenkins.isc.org/job/Fedora20_32_doxygen_doc/doxygen/d8/db2/libdhcp_user_chk.html">Kea Developer's Guide section dedicated to the user_chk library</link>
        that discusses how the code works internally. That, together with
        our general entries in <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://jenkins.isc.org/job/Fedora20_32_doxygen_doc/doxygen/">Hooks
        Framework section</link> should give you some pointers how to extend
        this library and perhaps even write your own from scratch.</para>

      </section>
      <section>
        <title>legal_log: Forensic Logging Hooks</title>
        <para>
        This section describes the forensic log hooks library. This library
        provides hooks that record a detailed log of lease assignments
        and renewals into a set of log files.  Currently this library
        is only available to ISC customers with a support contract.
        </para>
        <para>
        In many legal jurisdictions companies, especially ISPs, must record
        information about the addresses they have leased to DHCP clients.
        This library is designed to help with that requirement.  If the
        information that it records is sufficient it may be used directly.
        If your jurisdiction requires that you save a different set of
        information you may use it as a template or example and create your
        own custom logging hooks.
        </para>
        <para>
        This logging is done as a set of hooks to allow it to be customized
        to any particular need.  Modifying a hooks library is easier and
        safer than updating the core code.  In addition by using the hooks
        features those users who don't need to log this information can
        leave it out and avoid any performance penalties.
        </para>
        <section>
        <title>Log File Naming</title>
          <para>
          The names for the log files have the following form:
          </para>
<screen>
path/base-name.CCYYMMDD.txt
</screen>
          <para>
          The "path" and "base-name" are supplied in the
          configuration as described below see
          <xref linkend="forensic-log-configuration"/>.  The next part of the name is
          the date the log file was started, with four digits for year, two digits
          for month and two digits for day.  The file is rotated on a daily basis.
          </para>
          <note><para>
          When running Kea servers for both DHCPv4 and DHCPv6 the log names must
          be distinct.  See the examples in <xref linkend="forensic-log-configuration"/>.
          </para></note>
        </section>
        <section>
        <title>DHCPv4 Log Entries</title>
          <para>
          For DHCPv4 the library creates entries based on DHCPREQUEST messages
          and corresponding DHCPv4 leases intercepted by lease4_select
          (for new leases) and lease4_renew (for renewed leases) hooks.
          </para>
          <para>
          An entry is a single string with no embedded end-of-line markers,
          a prepended timestamp and has the following sections:
<screen>
timestamp address duration device-id {client-info} {relay-info}
</screen>
          </para>
          <para>
          Where:
          <itemizedlist>
            <listitem><para>
            timestamp - the current date and time the log entry was written
            in "%Y-%m-%d %H:%M:%S %Z" strftime format ("%Z" is the time zone
            name).
            </para></listitem>
            <listitem><para>
            address - the leased IPv4 address given out and whether it was
            assigned or renewed.
            </para></listitem>
            <listitem><para>
            duration - the lease lifetime expressed in days (if present),
            hours, minutes and seconds.  A lease lifetime of 0xFFFFFFFF will be
            denoted with the text "infinite duration".
            </para></listitem>
            <listitem><para>
            device-id - the client's hardware address shown as numerical type
            and hex digit string.
            </para></listitem>
            <listitem><para>
            client-info - the DHCP client id option (61) if present, shown as
            a hex string.
            </para></listitem>
            <listitem><para>
            relay-info - for relayed packets the giaddr and the RAI circuit-id,
            remote-id and subscriber-id options (option 82 sub
            options: 1, 2 and 6) if present.
            The circuit id and remote id are presented as hex strings
            </para></listitem>
          </itemizedlist>
          </para>
          <para>
          For instance (line breaks added for readability, they would not
          be present in the log file).
<screen>
2018-01-06 01:02:03 CET Address: 192.2.1.100 has been renewed for 1 hrs 52 min 15 secs to a device with hardware address: hwtype=1 08:00:2b:02:3f:4e, client-id: 17:34:e2:ff:09:92:54 connected via relay at address: 192.2.16.33, identified by circuit-id: 68:6f:77:64:79 and remote-id: 87:f6:79:77:ef
</screen>
        </para>
        <para>
        In addition to logging lease activity driven by DHCPv4 client traffic, it also
        logs entries for the following lease management control channel commands:
        lease4-add, lease4-update, and lease4-del.  Each entry is a single string
        with no embedded end-of-line markers and they will typically have the following
        forms:
        </para>
        <para>
        <command>lease4-add:</command>
<screen>
*timestamp* Administrator added a lease of address: *address* to a device with hardware address: *device-id*
</screen>
        Dependent on the arguments of the add command, it may also include the
        client-id and duration.
        </para>
        <para>
        Example:
<screen>
2018-01-06 01:02:03 CET Administrator added a lease of address: 192.0.2.202 to a device with hardware address: 1a:1b:1c:1d:1e:1f for 1 days 0 hrs 0 mins 0 secs
</screen>
        </para>
        <para>
        <command>lease4-update:</command>
<screen>
*timestamp* Administrator updated information on the lease of address: *address* to a device with hardware address: *device-id*
</screen>
        Dependent on the arguments of the update command, it may also include the
        client-id and lease duration.
        </para>
        <para>
        Example:
<screen>
2018-01-06 01:02:03 CET Administrator updated information on the lease of address: 192.0.2.202 to a device with hardware address: 1a:1b:1c:1d:1e:1f, client-id: 1234567890
</screen>
        </para>
        <para>
        <command>lease4-del:</command>
        Deletes have two forms, one by address and one by identifier and identifier type:
<screen>
*timestamp* Administrator deleted the lease for address: *address*
</screen>
        or
<screen>
*timestamp* Administrator deleted a lease for a device identified by: *identifier-type* of *identifier*
</screen>
        Currently only a type of @b hw-address (hardware address) is supported.
        </para>
        <para>
        Examples:
<screen>
2018-01-06 01:02:03 CET Administrator deleted the lease for address: 192.0.2.202

2018-01-06 01:02:12 CET Administrator deleted a lease for a device identified by: hw-address of 1a:1b:1c:1d:1e:1f
</screen>
        </para>
        </section>

        <section>
        <title>DHCPv6 Log Entries</title>
          <para>
          For DHCPv6 the library creates entries based on lease management
          actions intercepted by the lease6_select (for new leases), lease6_renew
          (for renewed leases) and lease6_rebind (for rebound leases).
          </para>
          <para>
          An entry is a single string with no embedded end-of-line markers,
          a prepended timestamp and has the following sections:
<screen>
timestamp address duration device-id {relay-info}*
</screen>
          </para>
          <para>
          Where:
          <itemizedlist>
            <listitem><para>
            timestamp - the current date and time the log entry was written
            in "%Y-%m-%d %H:%M:%S %Z" strftime format ("%Z" is the time zone
            name).
            </para></listitem>
            <listitem><para>
            address - the leased IPv6 address or prefix given out and whether
            it was assigned or renewed.
            </para></listitem>
            <listitem><para>
            duration - the lease lifetime expressed in days (if present),
            hours, minutes and seconds.  A lease lifetime of 0xFFFFFFFF will be
            denoted with the text "infinite duration".
            </para></listitem>
            <listitem><para>
            device-id - the client's DUID and hardware address (if present).
            </para></listitem>
            <listitem><para>
            relay-info - for relayed packets the content of relay agent
            messages, remote-id (code 37), subscriber-id (code 38) and
            interface-id (code 18) options if present. Note that
            interface-id option, if present, identifies the whole interface the
            relay agent received the message on. This typically translates to a
            single link in your network, but it depends on your specific network
            topology. Nevertheless, this is useful information to better scope
            down the location of the device, so it is being recorded, if present.
            </para></listitem>
          </itemizedlist>
          </para>
          <para>
          For instance (line breaks added for readability, they would not
          be present in the log file).
<screen>
2018-01-06 01:02:03 PST Address:2001:db8:1:: has been assigned for 0 hrs 11 mins 53 secs to a device with DUID: 17:34:e2:ff:09:92:54 and hardware address: hwtype=1 08:00:2b:02:3f:4e (from Raw Socket) connected via relay at address: fe80::abcd for client on link address: 3001::1, hop count: 1, identified by remote-id: 01:02:03:04:0a:0b:0c:0d:0e:0f and subscriber-id: 1a:2b:3c:4d:5e:6f
</screen>
        </para>
        <para>
        In addition to logging lease activity driven by DHCPv6 client traffic, it also
        logs entries for the following lease management control channel commands:
        lease6-add, lease6-update, and lease6-del.  Each entry is a single string
        with no embedded end-of-line markers and they will typically have the following
        forms:
        </para>
        <para>
        <command>lease6-add:</command>
<screen>
*timestamp* Administrator added a lease of address: *address* to a device with DUID: *DUID*
</screen>
        Dependent on the arguments of the add command, it may also include the hardware address and duration.
        </para>
        <para>
        Example:
<screen>
2018-01-06 01:02:03 PST Administrator added a lease of address: 2001:db8::3 to a device with DUID: 1a:1b:1c:1d:1e:1f:20:21:22:23:24 for 1 days 0 hrs 0 mins 0 secs
</screen>
        </para>
        <para>
        <command>lease6-update:</command>
<screen>
*timestamp* Administrator updated information on the lease of address: *address* to a device with DUID: *DUID*
</screen>
        Dependent on the arguments of the update command, it may also include the hardware address and lease duration.
        </para>
        <para>
        Example:
<screen>
2018-01-06 01:02:03 PST Administrator updated information on the lease of address: 2001:db8::3 to a device with DUID: 1a:1b:1c:1d:1e:1f:20:21:22:23:24, hardware address: 1a:1b:1c:1d:1e:1f
</screen>
        </para>
        <para>
        <command>lease6-del:</command>
        Deletes have two forms, one by address and one by identifier and identifier type:
<screen>
*timestamp* Administrator deleted the lease for address: *address*
</screen>
        or
<screen>
*timestamp* Administrator deleted a lease for a device identified by: *identifier-type* of *identifier*
</screen>
        Currently only a type of DUID is supported.
        </para>
        <para>
Examples:
<screen>
2018-01-06 01:02:03 PST Administrator deleted the lease for address: 2001:db8::3

2018-01-06 01:02:11 PST Administrator deleted a lease for a device identified by: duid of 1a:1b:1c:1d:1e:1f:20:21:22:23:24
</screen>
        </para>
        </section>
        <section xml:id="forensic-log-configuration">
        <title>Configuring the Forensic Log Hooks</title>
          <para>
          To use this functionality the hook library must be included in the
          configuration of the desired DHCP server modules. The legal_log
          library is installed alongside the Kea libraries in
          <filename>[kea-install-dir]/lib</filename> where
          <filename>kea-install-dir</filename> is determined by the
          "--prefix" option of the configure script.  It defaults to
          <filename>/usr/local</filename>.  Assuming the
          default value then, configuring kea-dhcp4 to load the legal_log
          library could be done with the following Kea4 configuration:
<screen>
"Dhcp4": { <userinput>
    "hooks-libraries": [
        {
            "library": "/usr/local/lib/libdhcp_legal_log.so",
            "parameters": {
                "path": "/var/kea/var",
                "base-name": "kea-forensic4"
            }
        },
        ...
    ] </userinput>
}
</screen>
          </para>
          <para>
          To configure it for kea-dhcp6, the commands are simply as shown below:
<screen>
"Dhcp6": { <userinput>
    "hooks-libraries": [
        {
            "library": "/usr/local/lib/libdhcp_legal_log.so",
            "parameters": {
                "path": "/var/kea/var",
                "base-name": "kea-forensic6"
            }
        },
        ...
    ] </userinput>
}
</screen>
          </para>
          <para>
          Two Hook Library parameters are supported:
          <itemizedlist>
            <listitem><para>
            path - the directory in which the forensic file(s) will be written.  The
            default value is
            <filename>[prefix]/kea/var</filename>.  The directory must exist.
            </para></listitem>
            <listitem><para>
            base-name - an arbitrary value which is used in conjunction with
            the current system date to form the current forensic file name.  It defaults
            to <filename>kea-legal</filename>.
            </para></listitem>
          </itemizedlist>
          </para>

          <para>
            If it is desired to restrict forensic logging to certain subnets, the
            "legal-logging" boolean parameter can be specified within a user context of
            these subnets. For example:
<screen>
"Dhcpv4" {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [
                {
                     "pool": "192.0.2.1 - 192.0.2.200"
                }
            ],
            <userinput>"user-context": {
                "legal-logging": false
            }</userinput>
        }
    ]
}
</screen>
              disables legal logging for the subnet "192.0.2.0/24". If this parameter
              is not specified, it defaults to 'true', which enables legal logging for
              the subnet.
          </para>

          <para>
            The following example demonstrates how to selectively disable legal logging
            for an IPv6 subnet.
<screen>
"Dhcpv6": {
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            "pools": [
                 {
                     "pool": "2001:db8:1::1-2001:db8:1::ffff"
                 }
            ],
            <userinput>"user-context": {
                "legal-logging": false
            }</userinput>
        }
    ]
}
</screen>
          </para>

          <para>
            See <xref linkend="dhcp4-user-contexts"/> and <xref linkend="dhcp6-user-contexts"/>
            to learn more about user contexts in Kea configuration.
          </para>
        </section>

        <section id="forensic-log-database">
        <title>Database backend</title>
          <para>
          Log entries can be inserted into a database when Kea is configured
          with database backend support: a table named 'logs' is used with a
          timestamp (timeuuid for Cassandra CQL) generated by the database
          software and a text log with the same format than for files
          without the timestamp.
          </para>
          <para>
          Please refer to <xref linkend="mysql-database"/> for MySQL,
          to <xref linkend="pgsql-database"/> for PostgreSQL or
          to <xref linkend="cql-database"/> for Cassandra CQL.
          Scripts are in
          <filename><replaceable>path-to-kea</replaceable>/share/kea/legal_log/scripts</filename> directory, for instance the PostgreSQL create schema
          command is:
<screen>
$ <userinput>psql -d <replaceable>database-name</replaceable> -U <replaceable>user-name</replaceable> -f <replaceable>path-to-kea</replaceable>/share/kea/legal_log/scripts/pgsql/legldb_create.pgsql</userinput>
Password for user <replaceable>user-name</replaceable>:
START TRANSACTION
CREATE TABLE
CREATE INDEX
CREATE TABLE
INSERT 0 1
COMMIT
$
</screen>
          </para>
          <para>
          Configuration parameters are extended by standard lease database
          parameters as defined in <xref linkend="database-configuration4"/>.
          The "type" parameter should be "mysql", "postgresql",  "cql" or
          be "logfile". When it is absent or set to "logfile" files are
          used.
          </para>
          <para>
          This database feature is experimental and will be likely
          improved, for instance to add an address / prefix index (currently
          the only index is the timestamp). No specific tools is provided
          to operate the database but standard tools are applicable,
          for instance to dump the logs table from a CQL database:
<screen>
$ <userinput>echo 'SELECT dateOf(timeuuid), log FROM logs;' | cqlsh -k <replaceable>database-name</replaceable></userinput>

 system.dateof(timeuuid)         | log
---------------------------------+---------------------------------------
 2018-01-06 01:02:03.227000+0000 | Address: 192.2.1.100 has been renewed ...
 ...
(12 rows)
$
</screen>
          </para>
        </section>
      </section>

      <section xml:id="flex-id">
        <title>flex_id: Flexible Identifiers for Host Reservations</title>
        <para>
          This section describes a hook application dedicated to generate
          flexible identifiers for host reservation. Kea software provides a way
          to handle host reservations that include addresses, prefixes, options,
          client classes and other features. The reservation can be based on
          hardware address, DUID, circuit-id or client-id in DHCPv4 and using
          hardware address or DUID in DHCPv6. However, there are sometimes
          scenarios where the reservation is more complex, e.g. uses other
          options that mentioned above, uses part of specific options or perhaps
          even a combination of several options and fields to uniquely identify
          a client. Those scenarios are addressed by the Flexible Identifiers
        hook application.</para>

        <para>Currently this library is only available to ISC customers with a
        support contract.</para>

        <para>The library allows for defining an expression, using notation
        initially used for client classification only. See <xref linkend="classification-using-expressions"/> for detailed description
        of the syntax available. One notable difference is that for client
        classification the expression currently has to evaluate to either true
        or false, while the flexible identifier expression is expected to
        evaluate to a string that will be used as identifier. It is a valid case
        for the expression to evaluate to empty string (e.g. in cases where a
        client does not sent specific options). This expression is then
        evaluated for each incoming packet. This evaluation generates an
        identifier that is used to identify the client. In particular, there may
        be host reservations that are tied to specific values of the flexible
        identifier.</para>

        <para>
          The library can be loaded in similar way as other hook libraries. It
          takes a mandatory parameter identifier-expression and optional
          boolean parameter replace-client-id:
<screen>
"Dhcp6": { <userinput>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<userinput>expression</userinput>",
                "replace-client-id": "<userinput>false</userinput>"
            }
        },
        ...
    ] </userinput>
}
</screen>
        </para>

        <para>
          The flexible identifier library supports both DHCPv4 and DHCPv6.
        </para>

        <para>
          EXAMPLE: Let's consider a case of an IPv6 network that has an
          independent interface for each of the connected customers. Customers
          are able to plug in whatever device they want, so any type of
          identifier (e.g. a client-id) is unreliable. Therefore the operator
          may decide to use an option inserted by a relay agent to differentiate
          between clients. In this particular deployment, the operator verified
          that the interface-id is unique for each customer facing
          interface. Therefore it is suitable for usage as reservation. However,
          only the first 6 bytes of the interface-id are interesting, because
          remaining bytes are either randomly changed or not unique between
          devices. Therefore the customer decided to use first 6 bytes of the
          interface-id option inserted by the relay agent. After adding "flex-id"
          host-reservation-identifiers goal can be achieved by using the
          following configuration:
<screen>
"Dhcp6": {
    "subnet6": [{ ..., // subnet definition starts here
    "reservations": [
        <userinput>"flex-id": "'port1234'"</userinput>, // value of the first 8 bytes of the interface-id
        "ip-addresses": [ "2001:db8::1" ]
    ],
    }], // end of subnet definitions
    "host-reservation-identifiers": ["duid", "flex-id"], // add "flex-id" to reservation identifiers
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<userinput>substring(relay6[0].option[18].hex,0,8)</userinput>"
            }
        },
        ...
    ]
}
</screen>
        </para>

        <para>
          NOTE: Care should be taken when adjusting the expression. If the
          expression changes, then all the flex-id values may change, possibly
          rendering all reservations based on flex-id unusable until they're
          manually updated. Therefore it is strongly recommended to start with
          the expression and a handful reservations, adjust the expression as
          needed and only after it was confirmed the expression does exactly
          what is expected out of it go forward with host reservations on any
          broader scale.
        </para>

        <para>
          flex-id values in host reservations can be specified in two
          ways. First, they can be expressed as hex string, e.g. bar string
          can be represented as 626174. Alternatively, it can be expressed
          as quoted value (using double and single quotes), e.g. "'bar'".
          The former is more convenient for printable characters, while hex
          string values are more convenient for non-printable characters.
        </para>
<screen>
"Dhcp6": {
    "subnet6": [{ ..., // subnet definition starts here
    "reservations": [
        <userinput>"flex-id": "01:02:03:04:05:06"</userinput>, // value of the first 8 bytes of the interface-id
        "ip-addresses": [ "2001:db8::1" ]
    ],
    }], // end of subnet definitions
    "host-reservation-identifiers": ["duid", "flex-id"], // add "flex-id" to reservation identifiers
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<userinput>vendor[4491].option[1026].hex</userinput>"
            }
        },
        ...
    ]
}
</screen>

        <para>
          When "replace-client-id" is set to false (which is the default setting),
          the flex-id hook library uses evaluated flexible identifier solely for
          identifying host reservations, i.e. searching for reservations within a
          database. This is a functional equivalent of other identifiers,
          similar to hardware address or circuit-id. However,
          this mode of operation has an implication that if a client device is
          replaced, it may cause a conflict between an existing lease (allocated
          for old device) and the new lease being allocated for the new device. The
          conflict arises because the same flexible identifier is computed for the
          replaced device and the server will try to allocate the same lease. The
          mismatch between client identifiers sent by new device and old device causes
          the server to refuse this new allocation until the old lease expires.
          A manifestation of this problem is dependant on specific expression
          used as flexible identifier and is likely to appear if you only use options
          and other parameters that are identifying where the device is
          connected (e.g. circuit-id), rather than the device identification
          itself (e.g. MAC address).
        </para>

        <para>
          The flex-id library offers a way to overcome the problem with lease conflicts
          by dynamically replacing client identifier (or DUID in DHCPv6 case) with a
          value derived from flexible identifier. The server processes the client's
          query as if flexible identifier was sent in the client identifier (or DUID)
          option. This guarantees that returning client (for which the same flexible
          identifier is evaluated) will be assigned the same lease despite the client
          identifier and/or MAC address change.
        </para>

        <para>
          The following is a stub configuration that enables this behavior:
<screen>
"Dhcp4": { <userinput>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<userinput>expression</userinput>",
                "replace-client-id": "<userinput>true</userinput>"
            }
        },
        ...
    ] </userinput>
}
</screen>
        </para>

        <para>
          In the DHCPv4 case, the value derived from the flexible identifier is formed
          by prepending 1 byte with a value of zero to flexible identifier. In the IPv6
          case, it is formed by prepanding two zero bytes before the flexible identifier.
        </para>

        <para>
          Note that for this mechanism to take effect, the DHCPv4 server must be configured
          to respect the client identifier option value during lease allocation, i.e.
          "match-client-id" must be set to true. See
          <xref linkend="dhcp4-match-client-id"/> for details. No additional settings
          are required for DHCPv6.
        </para>
        <para>
          If "replace-client-id" option is set to true, the value of "echo-client-id"
          parameter (that governs whether to send back a client-id option or
          not) is ignored.
        </para>

        <para>
          The <xref linkend="lease-cmds"/> section describes commands used to retrieve,
          update and delete leases using various identifiers, e.g. "hw-address",
          "client-id". The lease_cmds library doesn't natively support querying for
          leases by flexible identifier. However, when "replace-client-id" is set to
          true, it makes it possible to query for leases using a value derived from
          the flexible identifier. In the DHCPv4 case, the query will look similar to this:
<screen>
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "client-id",
        "identifier": "00:<userinput>54:64:45:66</userinput>",
        "subnet-id": 44
    }
}
</screen>

            where hexadecimal value of "54:64:45:66" is a flexible identifier computed
            for the client.
        </para>

        <para>
          In the DHCPv6 case, the corresponding query will look similar to this:
<screen>
{
    "command": "lease6-get",
    "arguments": {
        "identifier-type": "duid",
        "identifier": "00:00:<userinput>54:64:45:66</userinput>",
        "subnet-id": 10
    }
}</screen>

        </para>
      </section>

      <section xml:id="host-cmds">
        <title>host_cmds: Host Commands</title>
        <para>
          This section describes a hook application that offers a number of new
          commands used to query and manipulate host reservations. Kea provides
          a way to store host reservations in a database. In many larger
          deployments it is useful to be able to manage that information while
          the server is running. This library provides management commands for
          adding, querying and deleting host reservations in a safe way without
          restarting the server.  In particular, it validates the parameters, so
          an attempt to insert incorrect data e.g. add a host with conflicting
          identifier in the same subnet will be rejected. Those commands are
          exposed via command channel (JSON over unix sockets) and Control Agent
          (JSON over RESTful interface). Additional commands and capabilities
          related to host reservations will be added in the future.
        </para>

        <para>Currently this library is only available to ISC customers with a
        support contract.</para>

        <para>
          Currently three commands are supported: reservation-add (which adds
          new host reservation), reservation-get (which returns existing
          reservation if specified criteria are matched) and reservation-del
          (which attempts to delete a reservation matching specified
          criteria). To use commands that change the reservation information
          (currently these are reservation-add and reservation-del, but this
          rule applies to other commands that may be implemented in the future),
          hosts database must be specified (see hosts-databases description in
          <xref linkend="hosts-databases-configuration4"/> and <xref linkend="hosts-databases-configuration6"/>) and it must not operate in
          read-only mode. If the hosts-databases are not specified or are running
          in read-only mode, the host_cmds library will load, but any attempts
          to use reservation-add or reservation-del will fail.
        </para>

        <para>
          Additional host reservation commands are planned in the future. For
          a description of envisaged commands, see
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://kea.isc.org/wiki/ControlAPIRequirements">Control API
Requirements </link> document.</para>

        <para>
          All commands are using JSON syntax. They can be issued either using
          control channel (see <xref linkend="ctrl-channel"/>) or via Control
          Agent (see <xref linkend="kea-ctrl-agent"/>).
        </para>

        <para>
          The library can be loaded in similar way as other hook libraries. It
          does not take any parameters. It supports both DHCPv4 and DHCPv6
          servers.
<screen>
"Dhcp6": { <userinput>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_host_cmds.so"
        }
        ...
    ] </userinput>
}
</screen>
        </para>

        <section>
          <title>reservation-add command</title>
        <para>
          <command>reservation-add</command> allows for the insertion of a new host.  It
          takes a set of arguments that vary depending on the nature of the host
          reservation. Any parameters allowed in the configuration file that
          pertain to host reservation are permitted here. For details regarding
          IPv4 reservations, see <xref linkend="host-reservation-v4"/> and <xref linkend="host-reservation-v6"/>. There is one notable addition. A
          <command>subnet-id</command> must be specified.  This parameter is
          mandatory, because reservations specified in the configuration file
          are always defined within a subnet, so the subnet they belong to is
          clear. This is not the case with reservation-add, therefore the
          subnet-id must be specified explicitly. An example command can be as
          simple as:
<screen>{
    "command": "reservation-add",
    "arguments": {
        <userinput>"reservation": {
            "subnet-id": 1,
            "hw-address": "1a:1b:1c:1d:1e:1f",
            "ip-address": "192.0.2.202"
        }</userinput>
    }
}</screen> but can also take many more parameters, for example:

<screen>
{
    "command": "reservation-add",
    "arguments": {
        <userinput>"reservation":
            {
                "subnet-id":1,
                "client-id": "01:0a:0b:0c:0d:0e:0f",
                "ip-address": "192.0.2.205",
                "next-server": "192.0.2.1",
                "server-hostname": "hal9000",
                "boot-file-name": "/dev/null",
                "option-data": [
                    {
                        "name": "domain-name-servers",
                        "data": "10.1.1.202,10.1.1.203"
                    }
                ],
                "client-classes": [ "special_snowflake", "office" ]
            }</userinput>
    }
}</screen>

Here is an example of complex IPv6 reservation:
<screen>
{
    "command": "reservation-add",
    "arguments": {
        <userinput>"reservation":
            {
                "subnet-id":1,
                "duid": "01:02:03:04:05:06:07:08:09:0A",
                "ip-addresses": [ "2001:db8:1:cafe::1" ],
                "prefixes": [ "2001:db8:2:abcd::/64" ],
                "hostname": "foo.example.com",
                "option-data": [
                    {
                        "name": "vendor-opts",
                        "data": "4491"
                    },
                    {
                        "name": "tftp-servers",
                        "space": "vendor-4491",
                        "data": "3000:1::234"
                    }
                ]
            }</userinput>
    }
}</screen>
        </para>

        <para>
          The command returns a status that indicates either a success (result
          0) or a failure (result 1). Failed command always includes text
          parameter that explains the cause of failure. Example results:
          <screen>{ "result": 0, "text": "Host added." }</screen> Example failure:
          <screen>{ "result": 1, "text": "Mandatory 'subnet-id' parameter missing." }</screen>
        </para>

        <para>
          As <command>reservation-add</command> is expected to store the host,
          hosts-databases parameter must be specified in your configuration and
          databases must not run in read-only mode. In the future versions
          it will be possible to modify the reservations read from a
          configuration file. Please contact ISC if you are interested in this
          functionality.
        </para>
        </section>

        <section>
          <title>reservation-get command</title>
          <para><command>reservation-get</command> can be used to query the host
          database and retrieve existing reservations. There are two types of
          parameters this command supports: (subnet-id, address) or (subnet-id,
          identifier-type, identifier). The first type of query is used when the
          address (either IPv4 or IPv6) is known, but the details of the
          reservation aren't. One common use case of this type of query is to
          find out whether a given address is reserved or not. The second query
          uses identifiers. For maximum flexibility, Kea stores the host
          identifying information as a pair of values: type and the actual
          identifier. Currently supported identifiers are "hw-address", "duid",
          "circuit-id", "client-id" and "flex-id", but additional types may be
          added in the future. If any new identifier types are defined in the
          future, reservation-get command will support them
          automatically.</para>

          <para>
            An example command for getting a host reservation by (subnet-id,
            address) pair looks as follows:
<screen>
{
    "command": "reservation-get",
    "arguments": {
        "subnet-id": 1,
        "ip-address": "192.0.2.202"
    }
}</screen>

An example query by (subnet-id, identifier-type, identifier) looks as follows:
<screen>
{
    "command": "reservation-get",
    "arguments":
        "subnet-id": 4,
        "identifier-type": "hw-address",
        "identifier": "01:02:03:04:05:06"
    }
}</screen>

          </para>
          <para><command>reservation-get</command> typically returns result 0
          when the query was conducted properly. In particular, 0 is returned
          when the host was not found. If the query was successful a number
          of host parameters will be returned. An example of a query that
          did not find the host looks as follows:
<screen>{ "result": 0, "text": "Host not found." }</screen>

An example result returned when the host was found:
<screen>{
  "arguments": {
    "boot-file-name": "bootfile.efi",
    "client-classes": [

    ],
    "hostname": "somehost.example.org",
    "hw-address": "01:02:03:04:05:06",
    "ip-address": "192.0.2.100",
    "next-server": "192.0.0.2",
    "option-data": [

    ],
    "server-hostname": "server-hostname.example.org"
  },
  "result": 0,
  "text": "Host found."
}</screen>

An example result returned when the query was malformed:<screen>
{ "result": 1, "text": "No 'ip-address' provided and 'identifier-type'
                        is either missing or not a string." }</screen>
</para>

        </section>

        <section>
          <title>reservation-del command</title>
          <para><command>reservation-del</command> can be used to delete a
          reservation from the host database. There are two types of parameters
          this command supports: (subnet-id, address) or (subnet-id,
          identifier-type, identifier). The first type of query is used when the
          address (either IPv4 or IPv6) is known, but the details of the
          reservation aren't. One common use case of this type of query is to
          remove a reservation (e.g. you want a specific address to no longer be
          reserved). The second query uses identifiers. For maximum flexibility,
          Kea stores the host identifying information as a pair of values: type
          and the actual identifier. Currently supported identifiers are
          "hw-address", "duid", "circuit-id", "client-id" and "flex-id", but
          additional types may be added in the future. If any new identifier
          types are defined in the future, reservation-get command will support
          them automatically.</para>

          <para>
            An example command for deleting a host reservation by (subnet-id,
            address) pair looks as follows:
<screen>
{
    "command": "reservation-del",
    "arguments": {
        "subnet-id": 1,
        "ip-address": "192.0.2.202"
    }
}</screen>

An example deletion by (subnet-id, identifier-type, identifier) looks as follows:
<screen>
{
    "command": "reservation-del",
    "arguments":
        "subnet-id": 4,
        "identifier-type": "hw-address",
        "identifier": "01:02:03:04:05:06"
    }
}</screen>
          </para>
          <para>
            <command>reservation-del</command> returns result 0 when the host
            deletion was successful or 1 if it was not. A descriptive text is
            provided in case of error. Example results look as follows:
<screen>
{
    "result": 1,
    "text": "Host not deleted (not found)."
}</screen>

<screen>
{
    "result": 0,
    "text": "Host deleted."
}</screen>

<screen>
{
    "result": 1,
    "text": "Unable to delete a host because there is no hosts-database
             configured."
}</screen>
          </para>
        </section>
      </section>

      <!-- ================================================================= -->
      <!-- === lease_cmds ================================================== -->
      <!-- ================================================================= -->

      <section xml:id="lease-cmds">
        <title>lease_cmds: Lease Commands</title>
        <para>
          This section describes the hook library that offers a number of new
          commands used to manage leases. Kea provides a way to store lease
          information in several backends (memfile, MySQL, PostgreSQL and
          Cassandra). This library provides a unified interface that can
          manipulate leases in an unified, safe way. In particular, it allows
          things previously impossible: manipulate leases in memfile while Kea
          is running, sanity check changes, check lease existence and remove all
          leases belonging to specific subnet. It can also catch more obscure
          errors, like adding a lease with subnet-id that does not exist in the
          configuration or configuring a lease to use an address that is outside
          of the subnet to which it is supposed to belong.
        </para>

        <para>There are many use cases when an administrative command may be
        useful: during migration between servers (possibly even between
        different vendors), when a certain network is being retired, when a
        device has been disconnected and the sysadmin knows for sure that it
        will not be coming back. The "get" queries may be useful for automating
        certain management and monitoring tasks. They can also act as
        preparatory steps for lease updates and removals.</para>

        <para>
          This library provides the following commands:
          <itemizedlist>
            <listitem>
              <para><command>lease4-add</command> - adds new IPv4 lease;</para>
            </listitem>
            <listitem>
              <para><command>lease6-add</command> - adds new IPv6 lease;</para>
            </listitem>
            <listitem>
              <para><command>lease4-get</command> - checks if an IPv4 lease with
              the specified parameters exists and returns it if it does;</para>
            </listitem>
            <listitem>
              <para><command>lease6-get</command> - checks if an IPv6 lease with
              the specified parameters exists and returns it if it does;</para>
            </listitem>
            <listitem>
              <para><command>lease4-get-all</command> - returns all IPv4 leases
              or IPv4 leases for specified subnets;</para>
            </listitem>
            <listitem>
              <para><command>lease6-get-all</command> - returns all IPv6 leases
              or IPv6 leases for specified subnets;</para>
            </listitem>
            <listitem>
              <para><command>lease4-del</command> - attempts to delete an IPv4
              lease with the specified parameters;</para>
            </listitem>
            <listitem>
              <para><command>lease6-del</command> - attempts to delete an IPv6
              lease with the specified parameters;</para>
            </listitem>
            <listitem>
              <para><command>lease4-update</command> - updates an IPv4 lease;</para>
            </listitem>
            <listitem>
              <para><command>lease6-update</command> - updates an IPv6 lease;</para>
            </listitem>
            <listitem>
              <para><command>lease4-wipe</command> - removes all leases from a
              specific IPv4 subnet or all subnets;</para>
            </listitem>
            <listitem>
              <para><command>lease6-wipe</command> - removes all leases from a
              specific IPv6 subnet or all subnets;</para>
            </listitem>
          </itemizedlist>

        </para>

        <para>Lease commands library is part of the open source code and is
        available to every Kea user.</para>

        <para>
          All commands are using JSON syntax. They can be issued either using
          control channel (see <xref linkend="ctrl-channel"/>) or via Control
          Agent (see <xref linkend="kea-ctrl-agent"/>).
        </para>

        <para>
          The library can be loaded in the same way as other hook libraries. It
          does not take any parameters. It supports both DHCPv4 and DHCPv6
          servers.
<screen>
"Dhcp6": { <userinput>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_lease_cmds.so"
        }
        ...
    ] </userinput>
}
</screen>
        </para>

        <section>
          <title>lease4-add, lease6-add commands</title>
        <para>
          <command>lease4-add</command> and <command>lease6-add</command>
          commands allow for the creation of a new lease. Typically Kea creates a lease
          on its own, when it first sees a new device. However, sometimes it may
          be convenient to create the lease administratively. The
          <command>lease4-add</command> command requires at least three
          parameters: an IPv4 address, a subnet-id and an identifier: hardware
          (MAC) address. The simplest successful call might look as follows:
<screen>
{
    "command": "lease4-add",
    "arguments": {
        "subnet-id": 44,
        "ip-address": "192.0.2.202",
        "hw-address": "1a:1b:1c:1d:1e:1f"
    }
}
</screen>
        </para>

        <para><command>lease6-add</command> command requires four
        parameters: an IPv6 address, a subnet-id, and IAID value
        (identity association identifier, a value sent by clients) and
        a DUID:
<screen>
{
    "command": "lease6-add",
    "arguments": {
        "subnet-id": 66,
        "ip-address": "2001:db8::3",
        "duid": "1a:1b:1c:1d:1e:1f:20:21:22:23:24",
        "iaid": 1234
    }
}</screen>

<command>lease6-add</command> can be also used to add leases for IPv6
prefixes. In this case there are two parameters that must be
specified: type (set to value of "IA_PD") and a prefix
length. The actual prefix is set using ip-address field. For example,
to configure a lease for prefix 2001:db8:abcd::/48, the following
command can be used:

<screen>
{
    "command": "lease6-add",
    "arguments": {
        "subnet-id": 66,
        "type": "IA_PD",
        "ip-address": "2001:db8:abcd::",
        "prefix-len": 48,
        "duid": "1a:1b:1c:1d:1e:1f:20:21:22:23:24",
        "iaid": 1234
    }
}</screen>

The commands can take a number of additional optional parameters:
          <itemizedlist>
            <listitem>
              <para><command>valid-lft</command> - specifies the lifetime of the
              lease, expressed in seconds. If not specified, the value
              configured in the subnet related to specified subnet-id is
              used.</para>
            </listitem>
            <listitem>
              <para><command>expire</command> - timestamp of the lease
              expiration time, expressed in unix format (seconds since 1 Jan
              1970). If not specified, the default value is now + valid
              lifetime.</para>
            </listitem>
            <listitem>
              <para><command>fqdn-fwd</command> - specifies whether the lease
              should be marked as if forward DNS update was conducted. Note this
              only affects the lease parameter and the actual DNS update will
              not be conducted at the lease insertion time. If configured, a DNS
              update to remove the A or AAAA records will be conducted when the
              lease is removed due to expiration or being released by a
              client. If not specified, the default value is false. Hostname
              parameter must be specified in fqdn-fwd is set to true.</para>
            </listitem>
            <listitem>
              <para><command>fqdn-rev</command> - specifies whether the lease
              should be marked as if reverse DNS update was conducted. Note this
              only affects the lease parameter and the actual DNS update will
              not be conducted at the lease insertion time. If configured, a DNS
              update to remove the PTR record will be conducted when the lease
              is removed due to expiration or being released by a client. If not
              specified, the default value is false. Hostname parameter must be
              specified in fqdn-fwd is set to true.</para>
            </listitem>
            <listitem>
              <para><command>hostname</command> - specifies the hostname to be
              associated with this lease. Its value must be non-empty if either
              fqdn-fwd or fwdn-rev are set to true. If not specified, the
              default value is an empty string.</para>
            </listitem>
            <listitem>
              <para><command>hw-address</command> - hardware (MAC) address can
              be optionally specified for IPv6 lease. It is mandatory parameter
              for IPv4 lease.</para>
            </listitem>
            <listitem>
              <para><command>client-id</command> - client identifier is an
              optional parameter that can be specified for IPv4 lease.</para>
            </listitem>
            <listitem>
              <para><command>preferred-lft</command> - Preferred lifetime is an
              optional parameter for IPv6 leases. If not specified, the value
              configured for the subnet corresponding to the specified subnet-id
              is used. This parameter is not used in IPv4.</para>
            </listitem>
          </itemizedlist>
        </para>

        <para>Here's an example of more complex lease addition:

<screen>
{
    "command": "lease6-add",
    "arguments": {
        "subnet-id": 66,
        "ip-address": "2001:db8::3",
        "duid": "01:02:03:04:05:06:07:08",
        "iaid": 1234,
        "hw-address": "1a:1b:1c:1d:1e:1f",
        "preferred-lft": 500,
        "valid-lft": 1000,
        "expire": 12345678,
        "fqdn-fwd": true,
        "fqdn-rev": true,
        "hostname": "urania.example.org"
    }
}
</screen>
        </para>

        <para>
          The command returns a status that indicates either a success (result
          0) or a failure (result 1). Failed command always includes text
          parameter that explains the cause of failure. Example results:
          <screen>{ "result": 0, "text": "Lease added." }</screen> Example failure:
          <screen>{ "result": 1, "text": "missing parameter 'ip-address' (&lt;string&gt;:3:19)" }</screen>
        </para>


        <section>
          <title>lease4-get, lease6-get commands</title>
          <para><command>lease4-get</command> or <command>lease6-get</command>
          can be used to query the lease database and retrieve existing
          leases. There are two types of parameters the
          <command>lease4-get</command> supports: (address) or (subnet-id,
          identifier-type, identifier). There are two types for
          <command>lease6-get</command>: (address,type) or (subnet-id,
          identifier-type, identifier, IAID, type). The first type of query is
          used when the address (either IPv4 or IPv6) is known, but the details
          of the lease aren't. One common use case of this type of query is to
          find out whether a given address is being used or not. The second
          query uses identifiers. Currently supported identifiers for leases are:
          "hw-address" (IPv4 only), "client-id" (IPv4 only) and "duid" (IPv6 only).
          </para>

          <para>
            An example <command>lease4-get</command> command for getting a lease
            by an IPv4 address looks as follows:
<screen>
{
    "command": "lease4-get",
    "arguments": {
        "ip-address": "192.0.2.1"
    }
}
</screen>
          </para>

          <para>An example of the <command>lease6-get</command> query
          looks as follows:
<screen>
{
  "command": "lease6-get",
  "arguments": {
    "ip-address": "2001:db8:1234:ab::",
    "type": "IA_PD"
  }
}</screen>
          </para>

          <para>An example query by "hw-address" for IPv4 lease looks
          as follows:
<screen>
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "hw-address",
        "identifier": "08:08:08:08:08:08",
        "subnet-id": 44
    }
}</screen>

          </para>

          <para>An example query by "client-id" for IPv4 lease looks
          as follows:
<screen>
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "client-id",
        "identifier": "01:01:02:03:04:05:06",
        "subnet-id": 44
    }
}</screen>

          </para>

          <para>An example query by (subnet-id, identifier-type,
          identifier, iaid, type) for IPv6 lease looks as follows:
<screen>
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "duid",
        "identifier": "08:08:08:08:08:08",
        "iaid": 1234567,
        "type": "IA_NA",
        "subnet-id": 44
    }
}</screen>
The type is an optional parameter. Supported values are: IA_NA
(non-temporary address) and IA_PD (IPv6 prefix) are supported.
If not specified, IA_NA is assumed.
          </para>

          <para><command>leaseX-get</command> returns a result that indicates a
          result of the operation and lease details, if found. It has one of the
          following values: 0 (success), 1 (error) or 2 (empty). The empty
          result means that a query has been completed properly, but the object
          (a lease in this case) has not been found. The lease parameters, if
          found, are returned as arguments.
          </para>

          <para>
An example result returned when the host was found:
<screen>{
  "arguments": {
    "client-id": "42:42:42:42:42:42:42:42",
    "cltt": 12345678,
    "fqdn-fwd": false,
    "fqdn-rev": true,
    "hostname": "myhost.example.com.",
    "hw-address": "08:08:08:08:08:08",
    "ip-address": "192.0.2.1",
    "state": 0,
    "subnet-id": 44,
    "valid-lft": 3600
  },
  "result": 0,
  "text": "IPv4 lease found."
}</screen>
</para>

        </section>

        <section>
          <title>lease4-get-all, lease6-get-all commands</title>
          <para><command>lease4-get-all</command> and
          <command>lease6-get-all</command> are used to retrieve all
          IPv4 or IPv6 leases or all leases for the specified set of
          subnets. All leases are returned when there are no arguments
          specified with the command as in the following example:
<screen>
{
    "command": "lease4-get-all"
}
</screen>
          </para>

          <para>If the arguments are provided, it is expected that they contain
          "subnets" parameter, being a list of subnet identifiers for which the
          leases should be returned. For example, in order to retrieve all IPv6
          leases belonging to the subnets with identifiers 1, 2, 3 and 4:
<screen>
{
    "command": "lease6-get-all",
    "arguments": {
        "subnets": [ 1, 2, 3, 4 ]
    }
}
</screen>
          </para>

          <para>
            The returned response contains a detailed list of leases in the
            following format:
<screen>{
    "arguments": {
        "leases": [
            {
                "cltt": 12345678,
                "duid": "42:42:42:42:42:42:42:42",
                "fqdn-fwd": false,
                "fqdn-rev": true,
                "hostname": "myhost.example.com.",
                "hw-address": "08:08:08:08:08:08",
                "iaid": 1,
                "ip-address": "2001:db8:2::1",
                "preferred-lft": 500,
                "state": 0,
                "subnet-id": 44,
                "type": "IA_NA",
                "valid-lft": 3600
            },
            {
                "cltt": 12345678,
                "duid": "21:21:21:21:21:21:21:21",
                "fqdn-fwd": false,
                "fqdn-rev": true,
                "hostname": "",
                "iaid": 1,
                "ip-address": "2001:db8:0:0:2::",
                "preferred-lft": 500,
                "prefix-len": 80,
                "state": 0,
                "subnet-id": 44,
                "type": "IA_PD",
                "valid-lft": 3600
            }
        ]
    },
    "result": 0,
    "text": "2 IPv6 lease(s) found."
}</screen>
          </para>

          <warning>
            <para>The <command>lease4-get</command> and
            <command>lease6-get</command> commands may result in very
            large responses. This may have negative impact on the DHCP server
            responsiveness while the response is generated and transmitted
            over the control channel, as the server imposes no restriction
            on the number of leases returned as a result of this command.
            </para>
          </warning>

        </section>

        <section>
          <title>lease4-del, lease6-del commands</title>
          <para><command>leaseX-del</command> can be used to delete a lease from
          the lease database. There are two types of parameters this command
          supports, similar to leaseX-get commands: (address) for both v4 and
          v6, (subnet-id, identifier-type, identifier) for v4 and (subnet-id,
          identifier-type, identifier, type, IAID) for v6. The first type of
          query is used when the address (either IPv4 or IPv6) is known, but the
          details of the lease are not. One common use case of this type of query
          is to remove a lease (e.g. you want a specific address to no longer be
          used, no matter who may use it). The second query uses
          identifiers. For maximum flexibility, this interface uses identifiers
          as a pair of values: type and the actual identifier. Currently
          supported identifiers are "hw-address" (IPv4 only), "client-id"
          (IPv4 only) and "duid" (IPv6 only), but additional types may be added
          in the future. </para>

          <para>
            An example command for deleting a host reservation by address looks
            as follows:
<screen>
{
    "command": "lease4-del",
    "arguments": {
        "ip-address": "192.0.2.202"
    }
}</screen>

An example IPv4 lease deletion by "hw-address" looks as follows:

<screen>{
  "command": "lease4-del",
  "arguments": {
    "identifier": "08:08:08:08:08:08",
    "identifier-type": "hw-address",
    "subnet-id": 44
  }
}</screen>
          </para>

          <para><command>leaseX-del</command> returns a result that
          indicates a outcome of the operation. It has one of the
          following values: 0 (success), 1 (error) or 3 (empty). The
          empty result means that a query has been completed properly,
          but the object (a lease in this case) has not been found.
          </para>
        </section>

        <section>
          <title>lease4-update, lease6-update commands</title>
          <para><command>lease4-update</command> and
          <command>lease6-update</command> commands can be used to update
          existing leases. Since all lease database backends are indexed by IP
          addresses, it is not possible to update an address. All other fields
          may be updated. If an address needs to be changed, please use
          <command>leaseX-del</command> followed by
          <command>leaseX-add</command> commands.</para>

          <para>The optional boolean parameter "force-create" specifies
          if the lease should be created if it doesn't exist in the database.
          It defaults to false, which indicates that the lease is not created
          if it doesn't exist. In such case, an error is returned as a result
          of trying to update a non-existing lease. If the "force-create" parameter
          is set to true and the updated lease doesn't exist, the new lease is
          created as a result of receiving the <command>leaseX-update</command>.
          </para>

          <para>
            An example command updating IPv4 lease looks as follows:
<screen>{
  "command": "lease4-update",
  "arguments": {
    "ip-address": "192.0.2.1",
    "hostname": "newhostname.example.org",
    "hw-address": "1a:1b:1c:1d:1e:1f",
    "subnet-id": 44,
    "force-create": true
  }
}</screen>
          </para>

          <para>
            An example command updating IPv6 lease looks as follows:
<screen>{
  "command": "lease6-update",
  "arguments": {
    "ip-address": "2001:db8::1",
    "duid": "88:88:88:88:88:88:88:88",
    "iaid": 7654321,
    "hostname": "newhostname.example.org",
    "subnet-id": 66,
    "force-create": false
  }
}</screen>
          </para>
        </section>

        <section>
          <title>lease4-wipe, lease6-wipe commands</title>
          <para><command>lease4-wipe</command> and
          <command>lease6-wipe</command> are designed to remove all
          leases associated with a given subnet. This administrative
          task is expected to be used when existing subnet is being
          retired. Note that the leases are not properly expired,
          there are no DNS updates conducted, no log messages and
          hooks are not called for leases being removed.</para>

          <para>An example of <command>lease4-wipe</command> looks as follows:
<screen>{
  "command": "lease4-wipe",
  "arguments": {
    "subnet-id": 44
  }
}</screen>
          </para>

          <para>An example of <command>lease6-wipe</command> looks as follows:
<screen>{
  "command": "lease6-wipe",
  "arguments": {
    "subnet-id": 66
  }
}</screen>
          </para>

          <para>The commands return a textual description of the
          number of leases removed and 0 (success) status code if any
          leases were removed and 2 (empty) if there were no
          leases. Status code 1 (error) may be returned in case the
          parameters are incorrect or some other exception is
          encountered.</para>

          <para>The subnet-id 0 has special meaning. It tells Kea to
          delete leases from all configured subnets. Also, the
          subnet-id parameter may be omitted. If not specified, leases
          from all subnets are wiped.</para>

          <para>Note: not all backends support this command.</para>
        </section>
      </section>
    </section>

      <section xml:id="subnet-cmds">
        <title>subnet_cmds: Subnet Commands</title>
        <para>
          This section describes a hook application that offers a number of new
          commands used to query and manipulate subnet and shared network
          configurations in Kea.  This application is very useful in deployments
          with a large number of subnets being managed by the DHCP servers and
          when the subnets are frequently updated. The commands offer
          lightweight approach for manipulating subnets without a need to fully
          reconfigure the server and without affecting existing servers'
          configurations. An ability to manage shared networks (listing,
          retrieving details, adding new ones, removing existing ones, adding
          subnets to and removing from shared networks) is also provided.
        </para>

        <para>Currently this library is only available to ISC customers with a
        support contract.</para>

        <para>The following commands are currently supported:
        <itemizedlist mark="bullet">
          <listitem>
            <simpara><command>subnet4-list/subnet6-list</command>: lists all configured subnets
            </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>subnet4-get/subnet6-get</command>: retrieves detailed information about a specified subnet
          </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>subnet4-add/subnet6-add</command>: adds new subnet into server's configuration
          </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>subnet4-del/subnet6-del</command>: removes a subnet from the server's configuration
          </simpara>
          </listitem>

          <listitem>
          <simpara>
            <command>network4-list/network6-list</command>: lists all configured
            shared networks
          </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>network4-get/network6-get</command>: retrieves detailed
            information about specified shared network
          </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>network4-add/network6-add</command>: adds a new shared
            network to the server's configuration
          </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>network4-del/network6-del</command>: removes a shared
            network from the server's configuration
          </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>network4-subnet-add/network6-subnet-add</command>: adds
            existing subnet to existing shared network
          </simpara>
          </listitem>
          <listitem>
          <simpara>
            <command>network4-subnet-del/network6-subnet-del</command>: removes
            a subnet from existing shared network and demotes it to a plain
            subnet.
          </simpara>
          </listitem>

        </itemizedlist>
        </para>

        <section>
          <title>subnet4-list command</title>
          <para>
            This command is used to list all currently configured subnets. The
            subnets are returned in a brief form, i.e. a subnet identifier
            and subnet prefix is included for each subnet. In order to retrieve
            the detailed information about the subnet the
            <command>subnet4-get</command> should be used.
          </para>
          <para>
            This command has the simple structure:
<screen>
{
    "command": "subnet4-list"
}
</screen>
          </para>
          <para>
            The list of subnets returned as a result of this command is returned
            in the following format:
<screen>
{
    "result": 0,
    "text": "2 IPv4 subnets found",
    "arguments": {
    "subnets": [
        {
            "id": 10,
            "subnet": "10.0.0.0/8"
        },
        {
            "id": 100,
            "subnet": "192.0.2.0/24"
        }
    ]
}
</screen>
          </para>
          <para>
            If no IPv4 subnets are found, an error code is returned along with
            the error description.
          </para>
        </section>

        <section>
          <title>subnet6-list command</title>
          <para>
            This command is used to list all currently configured subnets. The
            subnets are returned in a brief form, i.e. a subnet identifier
            and subnet prefix is included for each subnet. In order to retrieve
            the detailed information about the subnet the
            <command>subnet6-get</command> should be used.
          </para>
          <para>
            This command has the simple structure:
<screen>
{
    "command": "subnet6-list"
}
</screen>
          </para>
          <para>
            The list of subnets returned as a result of this command is returned
            in the following format:
<screen>
{
    "result": 0,
    "text": "2 IPv6 subnets found",
    "arguments": {
    "subnets": [
        {
            "id": 11,
            "subnet": "2001:db8:1::/64"
        },
        {
            "id": 233,
            "subnet": "3000::/16"
        }
    ]
}
</screen>
          </para>
          <para>
            If no IPv6 subnets are found, an error code is returned along with
            the error description.
          </para>
        </section>

      <section>
        <title>subnet4-get command</title>
        <para>This command is used to retrieve detailed information about the
        specified subnet. This command usually follows the
        <command>subnet4-list</command>, which is used to discover available
        subnets with their respective subnet identifiers and prefixes. Any of
        those parameters can be then used in <command>subnet4-get</command>
        to fetch subnet information:
<screen>
{
    "command": "subnet4-get",
    "arguments": {
        "id": 10
    }
}</screen>

or

<screen>
{
    "command": "subnet4-get",
    "arguments": {
        "subnet": "10.0.0.0/8"
    }
}
</screen>
        </para>

        <para>
          If the subnet exists the response will be similar to this:
<screen>
{
    "result": 0,
    "text": "Info about IPv4 subnet 10.0.0.0/8 (id 10) returned",
    "arguments": {
        "subnets": [
            {
                "subnet": "10.0.0.0/8",
                "id": 1,
                "option-data": [
                    ....
                ]
                ...
            }
        ]
    }
}

</screen>
        </para>
      </section>

      <section>
        <title>subnet6-get command</title>
        <para>This command is used to retrieve detailed information about the
        specified subnet. This command usually follows the
        <command>subnet6-list</command>, which is used to discover available
        subnets with their respective subnet identifiers and prefixes. Any of
        those parameters can be then used in <command>subnet6-get</command>
        to fetch subnet information:
<screen>
{
    "command": "subnet6-get",
    "arguments": {
        "id": 11
    }
}
</screen>

or

<screen>
{
    "command": "subnet6-get",
    "arguments": {
        "subnet": "2001:db8:1::/64"
    }
}</screen>

If the subnet exists the response will be similar to this:
<screen>
{
    "result": 0,
    "text": "Info about IPv6 subnet 2001:db8:1::/64 (id 11) returned",
    "arguments": {
        "subnets": [
            {
                "subnet": "2001:db8:1::/64",
                "id": 1,
                "option-data": [
                    ...
                ]
                ....
            }
        ]
    }
}
</screen>
        </para>
      </section>

      <section>
        <title>subnet4-add</title>
        <para>
          This command is used to create and add new subnet to the existing
          server configuration. This operation has no impact on other
          subnets. The subnet identifier must be specified and must be
          unique among all subnets. If the identifier or a subnet prefix is
          not unique an error is reported and the subnet is not added.
        </para>
        <para>
          The subnet information within this command has the same structure
          as the subnet information in the server configuration file with the
          exception that static host reservations must not be specified
          within <command>subnet4-add</command>. The commands described in
          <xref linkend="host-cmds"/> should be used to add, remove and
          modify static reservations.
<screen>
{
    "command": "subnet4-add",
    "arguments": {
        "subnets": [ {
            "id": 123,
            "subnet": "10.20.30.0/24",
            ...
        } ]
    }
}
</screen>
        </para>

        <para>
          The response to this command has the following structure:
<screen>
{
    "result": 0,
    "text": "IPv4 subnet added",
    "arguments": {
        "subnets": [
            {
                "id": 123,
                "subnet": "10.20.30.0/24"
            }
        ]
    }
}
</screen>
        </para>
      </section>

      <section>
        <title>subnet6-add</title>
        <para>
          This command is used to create and add new subnet to the existing
          server configuration. This operation has no impact on other
          subnets. The subnet identifier must be specified and must be
          unique among all subnets. If the identifier or a subnet prefix is
          not unique an error is reported and the subnet is not added.
        </para>
        <para>
          The subnet information within this command has the same structure
          as the subnet information in the server configuration file with the
          exception that static host reservations must not be specified
          within <command>subnet6-add</command>. The commands described in
          <xref linkend="host-cmds"/> should be used to add, remove and
          modify static reservations.
<screen>
{
    "command": "subnet6-add",
    "arguments": {
        "subnet6": [ {
            "id": 234,
            "subnet": "2001:db8:1::/64",
            ...
        } ]
    }
}
</screen>
        </para>

        <para>
          The response to this command has the following structure:
<screen>
{
    "result": 0,
    "text": "IPv6 subnet added",
    "arguments": {
        "subnet6": [
            {
                "id": 234,
                "subnet": "2001:db8:1::/64"
            }
        ]
    }
}
</screen>
        </para>

        <para>
          It is recommended, but not mandatory to specify subnet
          id. If not specified, Kea will try to assign the next
          subnet-id value. This automatic ID value generator is
          simple. It returns a previously automatically assigned value
          increased by 1. This works well, unless you manually create
          a subnet with a value bigger than previously used. For
          example, if you call subnet4-add five times, each without
          id, Kea will assign IDs: 1,2,3,4 and 5 and it will work just
          fine. However, if you try to call subnet4-add five times,
          with the first subnet having subnet-id of value 3 and
          remaining ones having no subnet-id, it will fail. The first
          command (with explicit value) will use subnet-id 3, the
          second command will create a subnet with id of 1, the third
          will use value of 2 and finally the fourth will have the
          subnet-id value auto-generated as 3. However, since there is
          already a subnet with that id, it will fail.
        </para>
        <para>
          The general recommendation is to either: never use explicit
          values (so the auto-generated values will always work) or
          always use explicit values (so the auto-generation is never
          used). You can mix those two approaches only if you
          understand how the internal automatic subnet-id generation works.
        </para>

      </section>

      <section>
        <title>subnet4-del command</title>
        <para>
          This command is used to remove a subnet from the server's configuration.
          This command has no effect on other configured subnets but removing
          a subnet has certain implications which the server's administrator
          should be aware of.
        </para>
        <para>
          In most cases the server has assigned some leases to the clients
          belonging to the subnet. The server may also be configured with
          static host reservations which are associated with this subnet.
          The current implementation of the <command>subnet4-del</command>
          removes neither the leases nor host reservations associated with
          a subnet. This is the safest approach because the server doesn't
          loose track of leases assigned to the clients from this subnet.
          However, removal of the subnet may still cause configuration
          errors and conflicts. For example: after removal of the subnet,
          the server administrator may add a new subnet with the ID used
          previously for the removed subnet. This means that the existing
          leases and static reservations will be in conflict with this
          new subnet. Thus, we recommend that this command is used with extreme
          caution.
        </para>
        <para>
          This command can also be used to completely delete an IPv4 subnet that
          is part of a shared network. If you want to simply remove the subnet
          from a shared network and keep the subnet configuration, use
          <command>network4-subnet-del</command> command instead.
        </para>

        <para>The command has the following structure:
<screen>
{
    "command": "subnet4-del",
    "arguments": {
        "id": 123
    }
}
</screen>
        </para>
        <para>
          The example successful response may look like this:
<screen>
{
    "result": 0,
    "text": "IPv4 subnet 192.0.2.0/24 (id 123) deleted",
    "arguments": {
        "subnets": [
            {
                "id": 123,
                "subnet": "192.0.2.0/24"
            }
        ]
    }
}
</screen>
        </para>
      </section>

      <section>
        <title>subnet6-del command</title>
        <para>
          This command is used to remove a subnet from the server's configuration.
          This command has no effect on other configured subnets but removing
          a subnet has certain implications which the server's administrator
          should be aware of.
        </para>
        <para>
          In most cases the server has assigned some leases to the clients
          belonging to the subnet. The server may also be configured with
          static host reservations which are associated with this subnet.
          The current implementation of the <command>subnet6-del</command>
          removes neither the leases nor host reservations associated with
          a subnet. This is the safest approach because the server doesn't
          loose track of leases assigned to the clients from this subnet.
          However, removal of the subnet may still cause configuration
          errors and conflicts. For example: after removal of the subnet,
          the server administrator may add a new subnet with the ID used
          previously for the removed subnet. This means that the existing
          leases and static reservations will be in conflict with this
          new subnet. Thus, we recommend that this command is used with extreme
          caution.
        </para>
        <para>
          This command can also be used to completely delete an IPv6 subnet that
          is part of a shared network. If you want to simply remove the subnet
          from a shared network and keep the subnet configuration, use
          <command>network6-subnet-del</command> command instead.
        </para>

        <para>The command has the following structure:
<screen>
{
    "command": "subnet6-del",
    "arguments": {
        "id": 234
    }
}
</screen>
        </para>
        <para>
          The example successful response may look like this:
<screen>
{
    "result": 0,
    "text": "IPv6 subnet 2001:db8:1::/64 (id 234) deleted",
    "subnets": [
        {
            "id": 234,
            "subnet": "2001:db8:1::/64"
        }
    ]
}
</screen>
        </para>
      </section>

      <section>
        <title>network4-list, network6-list commands</title>
        <para>
          These commands are used to retrieve full list of currently configured
          shared networks. The list contains only very basic information about
          each shared network. If more details are needed, please use
          <command>network4-get</command> or <command>network6-get</command> to
          retrieve all information available. This command does not require any
          parameters and its invocation is very simple:
<screen>
{
    "command": "network4-list"
}
</screen>
An example response for <command>network4-list</command> looks as follows:
<screen>
{
    "arguments": {
        "shared-networks": [
            { "name": "floor1" },
            { "name": "office" }
        ]
    },
    "result": 0,
    "text": "2 IPv4 network(s) found"
}</screen>
<command>network6-list</command> follows exactly the same syntax for
both the query and the response.
        </para>
    </section>

    <section>
        <title>network4-get, network6-get commands</title>
        <para>
          These commands are used to retrieve detailed information
          about shared networks, including subnets currently
          being part of a given network. Both commands take one
          mandatory parameter <command>name</command>, which specify
          the name of shared network. An example command to retrieve
          details about IPv4 shared network with a name "floor13"
          looks as follows:
<screen>
{
    "command": "network4-get",
    "arguments": {
        "name": "floor13"
    }
}</screen>
An example response could look as follows:
<screen>
{
    "result": 0,
    "text": "Info about IPv4 shared network 'floor13' returned",
    "arguments": {
        "shared-networks": [
        {
            "match-client-id": true,
            "name": "floor13",
            "option-data": [ ],
            "rebind-timer": 90,
            "relay": {
                "ip-address": "0.0.0.0"
            },
            "renew-timer": 60,
            "reservation-mode": "all",
            "subnet4": [
                {
                    "subnet": "192.0.2.0/24",
                    "id": 5,
                    // many other subnet specific details here
                },
                {
                    "id": 6,
                    "subnet": "192.0.3.0/31",
                    // many other subnet specific details here
                }
            ],
            "valid-lifetime": 120
        }
        ]
    }
}
</screen>
Note that actual response contains many additional fields that are
omitted here for clarity. The response format is exactly the same as
used in <command>config-get</command>, just is limited to returning
shared networks information.
        </para>
    </section>

    <section>
        <title>network4-add, network6-add commands</title>
        <para>
          These commands are used to add a new shared network. New
          network has to have unique name. This command requires one parameter
          <command>shared-networks</command>, which is a list and
          should contain exactly one entry that defines the
          network. The only mandatory element for a network is its
          name. Although it does not make operational sense, it is
          allowed to add an empty shared network that does not have
          any subnets in it. That is allowed for testing purposes, but
          having empty networks (or with only one subnet) is
          discouraged in production environments. For details regarding
          syntax, see <xref linkend="shared-network4"/> and <xref
          linkend="shared-network6"/>.
        </para>
        <note><para>As opposed to parameter inheritance during full
          new configuration processing, this command does not fully handle
          parameter inheritance and any missing parameters will be
          filled with default values, rather than inherited from
          global scope.</para></note>
        <para>
          An example that showcases how to add a new IPv4 shared network looks
          as follows:
<screen>
{
    "command": "network4-add",
    "arguments": {
        "shared-networks": [ {
            "name": "floor13",
            "subnet4": [
            {
                "id": 100,
                "pools": [ { "pool": "192.0.2.2-192.0.2.99" } ],
                "subnet": "192.0.2.0/24",
                "option-data": [
                    {
                        "name": "routers",
                        "data": "192.0.2.1"
                    }
                ]
            },
            {
                "id": 101,
                "pools": [ { "pool": "192.0.3.2-192.0.3.99" } ],
                "subnet": "192.0.3.0/24",
                "option-data": [
                    {
                        "name": "routers",
                        "data": "192.0.3.1"
                    }
                ]
            } ]
        } ]
    }
}
</screen>
Assuming there was no shared network with a name floor13 and no subnets with id
100 and 101 previously configured, the command will be successful and will
return the following response:
<screen>
{
    "arguments": {
        "shared-networks": [ { "name": "floor13" } ]
    },
    "result": 0,
    "text": "A new IPv4 shared network 'floor13' added"
}
</screen>
The <command>network6-add</command> uses the same syntax for both the query and
the response. However, there are some parameters that are IPv4-only
(e.g. match-client-id) and some are IPv6-only (e.g. interface-id). The same
applies to subnets within the network.
        </para>
    </section>
    <section>
        <title>network4-del, network6-del commands</title>
        <para>
          These commands are used to delete existing shared
          networks. Both commands take exactly one parameter 'name' that
          specifies the name of the network to be removed. An example invocation
          of <command>network4-del</command> command looks as follows:
<screen>
{
    "command": "network4-del",
    "arguments": {
        "name": "floor13"
    }
}
</screen>
Assuming there was such a network configured, the response will look similar to
the following:
<screen>
{
    "arguments": {
        "shared-networks": [
            {
                "name": "floor13"
            }
        ]
    },
    "result": 0,
    "text": "IPv4 shared network 'floor13' deleted"
}</screen>
The <command>network6-del</command> command uses exactly the same syntax for
both the command and the response.
        </para>

        <para>If there are any subnets belonging to the shared network
        being deleted, they will be demoted to a plain subnet. There
        is an optional parameter called
        <command>subnets-action</command> that, if specified, takes
        one of two possible values: <command>keep</command> (which is
        the default) and <command>delete</command>. It controls
        whether the subnets be demoted to plain subnets or removed. An
        example usage in network6-del command that deletes the shared
        network and all subnets in it could looks like as follows:
<screen>
{
    "command": "network4-del",
    "arguments": {
        "name": "floor13",
        "subnets-action": "delete"
    }
}
</screen>
        </para>

        <para>Alternatively, if you want to completely remove the
        subnets, you may use <command>subnet4-del</command> or
        <command>subnet6-del</command> commands.</para>

    </section>
    <section>
        <title>network4-subnet-add, network6-subnet-add commands</title>
        <para>
          These commands are used to add existing subnets to existing shared
          networks. There are several ways to add new shared network. System
          administrator can add the whole shared network at once, either by
          editing a configuration file or by calling
          <command>network4-add</command> or <command>network6-add</command>
          commands with desired subnets in it. This approach works better for completely
          new shared subnets. However, there may be cases when an existing
          subnet is running out of addresses and needs to be extended with
          additional address space. In other words another subnet has to be
          added on top of it. For this scenario, a system administrator can use
          <command>network4-add</command> or <command>network6-add</command> and
          then add existing subnet to this newly created shared network  using
          <command>network4-subnet-add</command> or
          <command>network6-subnet-add</command>.
        </para>
        <para>
          The <command>network4-subnet-add</command> and
          <command>network6-subnet-add</command> commands take two parameters:
          <command>id</command>, which is an integer and specifies subnet-id of existing subnet to
          be added to a shared network; and <command>name</command>, which
          specifies name of the shared network the subnet will be added to. The
          subnet must not belong to any existing network. In case you want to
          reassign a subnet from one shared network to another, please use
          <command>network4-subnet-del</command> or
          <command>network6-subnet-del</command> commands first.
        </para>
        <para>
          An example invocation of <command>network4-subnet-add</command>
          command looks as follows:
<screen>
{
    "command": "network4-subnet-add",
    "arguments": {
        "name": "floor13",
        "id": 5
    }
}</screen>
Assuming there is a network named 'floor13', there is a subnet with subnet-id 5
and it is not a part of existing network, the command will return a response
similar to the following:
<screen>
{
    "result": 0,
    "text": "IPv4 subnet 10.0.0.0/8 (id 5) is now part of shared network 'floor1'"
}</screen>
        The <command>network6-subnet-add</command> command uses exactly the same syntax for
both the command and the response.
        </para>

        <note><para>As opposed to parameter inheritance during full
          new configuration processing or when adding a new shared network with
          new subnets, this command does not fully handle
          parameter inheritance and any missing parameters will be
          filled with default values, rather than inherited from
          global scope or from the shared network.</para></note>
    </section>
    <section>
        <title>network4-subnet-del, network6-subnet-del commands</title>
        <para>
          These commands are used to remove a subnet that is part of existing shared
          network and demote it to a plain, stand-alone subnet. If you want to
          remove a subnet completely, use <command>subnet4-del</command> or
          <command>subnet6-del</command> commands instead.
          The <command>network4-subnet-del</command> and
          <command>network6-subnet-del</command> commands take two parameters:
          <command>id</command>, which is an integer and specifies subnet-id of
          existing subnet to be removed from a shared network; and
          <command>name</command>, which specifies name of the shared network
          the subnet will be removed from.
        </para>
        <para>An example invocation of the
        <command>network4-subnet-del</command> command looks as follows:
 <screen>
 {
    "command": "network4-subnet-del",
    "arguments": {
        "name": "floor13",
        "id": 5
    }
 }</screen>
 Assuming there was a subnet with subnet-id equal to 5 that was part of a shared
 network named 'floor13', the response would look similar to the following:
<screen>
{
    "result": 0,
    "text": "IPv4 subnet 10.0.0.0/8 (id 5) is now removed from shared network 'floor13'"
}</screen>
The <command>network6-subnet-del</command> command uses exactly the same syntax for
both the command and the response.
        </para>
    </section>

    </section> <!-- end of subnet commands -->

    <section xml:id="high-availability-library">
      <title>libdhcp_ha: High Availability</title>
      <para>
        High Availability (HA) of the DHCP service is provided by running multiple
        cooperating server instances. If any of these instances crashes, a surviving
        server instance can continue providing the reliable service to the clients. Many
        DHCP servers implementations include "DHCP Failover" protocol, which most
        significant features are: communication between the servers, partner
        failure detection and leases synchronization between the servers.
        Although it may be useful for some users to use a "standard" failover
        protocol, it seems that most of the Kea users are simply interested in
        "some working solution" which guarantees high availability of the DHCP
        service. Therefore, Kea HA hook library derives major concepts from the
        DHCP Failover protocol but uses its own solutions for communication,
        configuration and its own state machine, which greatly simplifies its
        implementation and generally better fits into Kea. This document purposely
        uses the term "High Availability" rather than "Failover" to emphasize that
        it is not the Failover protocol implementation.
      </para>
      <para>
        The following sections describe the configuration and operation of the Kea
        HA hook library.
      </para>

      <section>
        <title>Supported Configurations</title>
        <para>The Kea HA hook library supports two configurations also known as HA
        modes: load balancing and hot standby. In the load balancing mode, there
        are two servers responding to the DHCP requests. The load balancing function
        is implemented as described in RFC3074, with each server responding to
        1/2 of received DHCP queries. When one of the servers allocates a lease
        for a client, it notifies the partner server over the control channel
        (RESTful API), so as the partner can save the lease information in its
        own database. If the communication with the partner is unsuccessful,
        the DHCP query is dropped and the response is not returned to the DHCP
        client. If the lease update is successful, the response is returned to
        the DHCP client by the server which has allocated the lease. By
        exchanging the lease updates, both servers get a copy of all leases
        allocated by the entire HA setup and any of the servers can be switched
        to handle the entire DHCP traffic if its partner crashes.</para>

        <para>In the load balancing configuration, one of the servers must be
        designated as "primary" and the other server is designated as "secondary".
        Functionally, there is no difference between the two during the normal
        operation. This distniction is required when the two servers are
        started at (nearly) the same time and have to synchronize their
        lease databases. The primary server synchronizes the database first.
        The secondary server waits for the primary server to complete the
        lease database synchronization before it starts the synchronization.
        </para>

        <para>In the hot standby configuration one of the servers is designated as
        "primary" and the second server is designated as "secondary". During the
        normal operation, the primary server is the only one that responds to
        the DHCP requests. The secodary server receives lease updates from the
        primary over the control channel. However, it does not respond to any
        DHCP queries as long as the primary is running or, more accurately,
        until the secondary considers the primary to be offline. When the
        secondary server detects the failure of the primary, it starts
        responding to all DHCP queries.
        </para>

        <para>In the configurations described above, the primary, secondary and
        standby are referred to as "active" servers, because they receive
        lease updates and can automatically react to the partner's failures by
        responding to the DHCP queries which would normally be handled by the
        partner. The HA hook library supports another server type (role) -
        backup server. The use of the backup servers is optional. They can be used
        in both load balancing and hot standby setup, in addition to the active
        servers. There is no limit on the number of backup servers in the HA
        setup. However, the presence of the backup servers increases latency
        of the DHCP responses, because not only do active servers send lease
        updates to each other, but also to the backup servers.
        </para>
      </section>

      <section>
        <title>Server States</title>
        <para>The DHCP server operating within an HA setup runs a state machine
        and the state of the server can be retrieved by its peers using the
        <command>ha-heartbeat</command> command sent over the RESTful API. If
        the partner server doesn't respond to the <command>ha-heartbeat</command>
        command longer than configured amount of time, the communication is
        considered interrupted and the server may (depending on the configuration)
        use additional measures to verify if the partner is still operating.
        If it finds that the partner is not operating, the server transitions
        to the <command>partner-down</command> state to handle the entire
        DHCP traffic directed to the system.</para>

        <para>In this case, the surviving server continues to send the
        <command>ha-heartbeat</command> command to detect when the partner wakes
        up. The partner synchronizes the lease database and when it is finally
        ready to operate, the surviving server returns to the normal operation,
        i.e. <command>load-balancing</command> or <command>hot-standby</command>
        state.</para>

        <para>The following is the list of all possible states into which the
        servers may transition:

        <itemizedlist mark="bullet">
          <listitem><para><command>backup</command> - normal operation of the
          backup server. In this state it receives lease updates from the active
          servers.</para></listitem>

          <listitem><para><command>hot-standby</command> - normal operation of
          the active server running in the hot standby mode. Both primary and
          standby server are in this state during their normal operation.
          The primary server is responding to the DHCP queries and sends lease updates
          to the standby server and to the backup servers, if any backup servers
          are present.</para></listitem>

          <listitem><para><command>load-balancing</command> - normal operation
          of the active server running in the load balancing mode. Both primary
          and secondary server are in this state during their normal operation.
          Both servers are responding to the DHCP queries and send lease updates
          to each other and to the backup servers, if any backup servers are
          present.</para></listitem>

          <listitem><para><command>partner-down</command> - an active server
          transitions to this state after detecting that its partner (another
          active server) is offline. The server doesn't transition to this state
          if any of the backup servers is unavailable. In the <command>
          partner-down</command> state the server responds to all DHCP queries,
          so also those queries which are normally handled by the active server
          which is now unavailable.</para></listitem>

          <listitem><para><command>ready</command> - an active server transitions
          to this state after synchronizing its lease database with an active
          partner. This state is to indicate to the partner (likely being in the
          <command>partner-down</command> state that it may return to the
          normal operation. When it does, the server being in the <command>
          ready</command> state will also start normal operation.</para>
          </listitem>

          <listitem><para><command>syncing</command> - an active server
          transitions to this state to fetch leases from the active partner
          and update the local lease database. When it this state, it
          issues the <command>dhcp-disable</command> to disable the DHCP
          service of the partner from which the leases are fetched. The DHCP
          servie is disabled for the maximum time of 60 seconds, after which
          it is automatically enabled, in case the syncing partner has died
          again failing to re-enable the service. If the synchronization is
          completed the syncing server issues the <command>dhcp-enable
          </command> to re-enable the DHCP service of the partner. The
          syncing operation is synchronous. The server is waiting for an
          answer from the partner and is not doing anything else while the
          leases synchronization takes place.</para></listitem>

          <listitem><para><command>waiting</command> - each started server
          instance enters this state. The backup server will transition
          directly from this statet to the <command>backup</command> state.
          An active server will send heartbeat to its partner to check its
          state. If the partner appears to be unavailable the server will
          transition to the <command>partner-down</command>, otherwise it
          will transition to the <command>syncing</command> state and attempt
          to synchronize the lease database. If both servers appear to be
          in this state (concurrent startup) the primary server will
          synchronize first. The secondary or standby server will remain
          in the <command>waiting</command> state until the primary
          synchronizes the database.</para></listitem>.
        </itemizedlist>

        <para>Whether the server responds to the DHCP queries and which
        queries it responds to is a matter of the server's state, if no
        administrative action is performed to configure the server
        otherwise. The following table provides the default behavior for
        various states.</para>

        <para>
          <table frame="all" xml:id="ha-default-states-behavior">
            <title>Default behavior of the server in various HA states</title>
            <tgroup cols="4">
              <colspec colname="state"/>
              <colspec colname="server type" align="center"/>
              <colspec colname="dhcp-service" align="center"/>
              <colspec colname="dhcp-service-scopes" align="center"/>
              <thead>
                <row>
                  <entry>State</entry>
                  <entry>Server Type</entry>
                  <entry>DHCP Service</entry>
                  <entry>DHCP Service Scopes</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>backup</entry>
                  <entry>backup server</entry>
                  <entry>disabled</entry>
                  <entry>none</entry>
                </row>
                <row>
                  <entry>hot-standby</entry>
                  <entry>primary or standby (hot standby mode)</entry>
                  <entry>enabled</entry>
                  <entry><command>ha_server1</command> if primary, none otherwise</entry>
                </row>
                <row>
                  <entry>load-balancing</entry>
                  <entry>primary or secondary (load balancing mode)</entry>
                  <entry>enabled</entry>
                  <entry><command>ha_server1</command> or <command>ha_server2</command></entry>
                </row>
                <row>
                  <entry>partner-down</entry>
                  <entry>active server</entry>
                  <entry>enabled</entry>
                  <entry>all scopes</entry>
                </row>
                <row>
                  <entry>ready</entry>
                  <entry>active server</entry>
                  <entry>disabled</entry>
                  <entry>none</entry>
                </row>
                <row>
                  <entry>syncing</entry>
                  <entry>active server</entry>
                  <entry>disabled</entry>
                  <entry>none</entry>
                </row>
                <row>
                  <entry>waiting</entry>
                  <entry>any server</entry>
                  <entry>disabled</entry>
                  <entry>none</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>

        </para>

        <para>The DHCP service scopes require some explanation. The HA
        configuration must specify a unique name for each server within
        the HA setup. This document uses the following convention within
        provided examples: <command>server1</command> for a primary server,
        <command>server2</command> for the secondary or standby server and
        <command>server3</command> for the backup server. In the real life
        any names can be used as long as they remain unique.</para>

        <para>In the load balancing mode there are two scopes named after
        the active servers: <command>ha_server1</command> and <command>
        ha_server2</command>. The DHCP queries load balanced to the
        <command>server1</command> belong to the <command>ha_server1</command>
        scope and the queries load balanced to the <command>server2</command>
        belong to the <command>ha_server2</command> scope. If any of the
        servers is in the <command>partner-down</command> state, it is
        responsible for serving both scopes.</para>

        <para>In the hot standby mode, there is only one scope <command>
        ha_server1</command> because only the <command>server1</command>
        is responding to the DHCP queries. If that server crashes, the
        <command>server2</command> becomes responsible for this scope.
        </para>

        <para>The backup servers do not have their own scopes. In some
        cases they can be used to respond to the queries belonging to
        the scopes of the active servers. Also, a server which is neither
        in the partner-down state nor in the normal operation serves
        no scopes.</para>

        <para>The scope names can be used to associate pools, subnets
        and networks with certain servers, so as only these servers
        can allocate addresses or prefixes from those pools, subnets
        or network. This is done via the client classification mechanism
        (see below).</para>
      </section>

      <section xml:id="ha-load-balancing-config">
        <title>Load Balancing Configuration</title>
        <para>The following is the configuration snippet which enables
        high availability on the primary server within the load balancing
        configuration. The same configuration should be applied on the
        secondary and the backup server, with the only difference that
        the <command>this-server-name</command> should be set to
        <command>server2</command> and <command>server3</command>
        on those servers respectively.
<screen>
{
"Dhcp4": {

    ...

    "hooks-libraries": [
        {
            "library": "/usr/lib/hooks/libdhcp_lease_cmds.so",
            "parameters": { }
        },
        {
            "library": "/usr/lib/hooks/libdhcp_ha.so",
            "parameters": {
                "high-availability": [ {
                    "this-server-name": "server1",
                    "mode": "load-balancing",
                    "heartbeat-delay": 10,
                    "max-response-delay": 10,
                    "max-ack-delay": 5,
                    "max-unacked-clients": 5,
                    "peers": [
                        {
                            "name": "server1",
                            "url": "http://192.168.56.33:8080/",
                            "role": "primary",
                            "auto-failover": true
                        },
                        {
                            "name": "server2",
                            "url": "http://192.168.56.66:8080/",
                            "role": "secondary",
                            "auto-failover": true
                        },
                        {
                            "name": "server3",
                            "url": "http://192.168.56.99:8080/",
                            "role": "backup",
                            "auto-failover": false
                        }
                    ]
                } ]
            }
        }
    ],

    "subnet4": [
        {
            "subnet": "192.0.3.0/24",
            "pools": [
                {
                    "pool": "192.0.3.100 - 192.0.3.150",
                    "client-class": "ha_server1"
                },
                {
                    "pool": "192.0.3.200 - 192.0.3.250",
                    "client-class": "ha_server2"
                }
            ],

            "option-data": [
                {
                    "name": "routers",
                    "data": "192.0.3.1"
                }
            ],

            "relay": { "ip-address": "10.1.2.3" }
        }
    ],

    ...

}

}
</screen>
        </para>

        <para>Two hook libraries must be loaded to enable HA:
        <filename>libdhcp_lease_cmds.so</filename> and
        <filename>libdhcp_ha.so</filename>. The former provides the
        implemenation of the HA feature. The latter enables control
        commands required by HA to fetch and manipulate leases on the
        remote servers. In the example provided above, it is assumed that
        Kea libraries are installed in the <filename>/usr/lib</filename>
        directory. If Kea is not installed in the /usr directory, the
        hook libraries locations must be updated accordingly.
        </para>

        <para>The HA configuration is specified within the scope of the
        <filename>libdhcp_ha.so</filename>. Note that the top level
        parameter <command>high-availability</command> is a list, even
        though it currently contains only one entry. In the future this
        configuration is likely to be extended to contain more entries,
        if the particular server can participate in more than one
        HA relationships.</para>

        <para>The following are the global parameters which control the server's
        behavior with respect to HA:
        <itemizedlist mark="bullet">
          <listitem><para><command>this-server-name</command> - is a unique
          identifier of the server within this HA setup. It must match with one
          of the servers specified within <command>peers</command> list.
          </para></listitem>

          <listitem><para><command>mode</command> - specifies a HA mode
          of operation. Currently supported modes are <command>load-balancing
          </command> and <command>hot-standby</command>.</para></listitem>

          <listitem><para><command>heartbeat-delay</command> - specifies
          a duration in seconds between the last heartbeat (or other command sent
          to the partner) and sending the next heartbeat. The heartbeats are sent
          periodically to gather the status of the partner and to verify whether
          the partner is still operating. The default value of this parameter is
          10.</para></listitem>

          <listitem><para><command>max-response-delay</command> - specifies a
          duration in seconds since the last successful communication with the
          partner, after which the server assumes that the communication with
          the partner is interrupted. This duration should be greater than
          the <command>heartbeat-delay</command>. Usually it is a greater than
          the duration of multiple <command>heartbeat-delay</command> values.
          When the server detects that the communication is interrupted, it
          may transition to the <command>partner-down</command> state (when
          <command>max-unacked-clients</command> is 0) or trigger failure
          detection procedure using the values of the two parameters below.
          The default value of this parameter is 60.
          </para></listitem>

          <listitem><para><command>max-ack-delay</command> - is one of
          the parameters controlling partner failure detection. When the
          communication with the partner is interrupted, the server examines values
          of the <command>secs</command> field (DHCPv4) or <command>Elapsed Time
          </command> option (DHCPv6) which denote how long the DHCP client has been
          trying to communicate with the DHCP server. This parameter specifies the
          maximum time for the client to try to communicate with the DHCP server,
          after which this server assumes that the client failed to communicate
          with the DHCP server (is "unacked"). The default value of this parameter
          is 10.</para></listitem>

          <listitem><para><command>max-unacked-clients</command> - specifies
          how many "unacked" clients are allowed (see <command>max-ack-delay</command>)
          before this server assumes that the partner is offline and transitions
          to the <command>partner-down</command> state. The special value of 0
          is allowed for this parameter which disables failure detection
          mechanism. In this case, the server which can't communicate with the
          partner over the control channel assumes that the partner server is
          down and transitions to the <command>partner-down</command> state
          immediately. The default value of this parameter is 10.</para>
          </listitem>

        </itemizedlist>
        </para>

        <para>
          The values of <command>max-ack-delay</command> and
          <command>max-unacked</command> must be selected carefully, taking
          into account specifics of the network in which DHCP servers are
          operating. Note that the server in question may not respond to some
          of the DHCP clients because these clients are not to be serviced
          by this server (per administrative policy). The server may also
          drop malformed queries from the clients. Therefore, selecting too
          low value for the <command>max-unacked-clients</command> may
          result in transitioning to the <command>partner-down</command>
          state even though the partner is still operating. On the other
          hand, selecting too high value may result in never transitioning
          to the <command>partner-down</command> state if the DHCP
          traffic in the network is very low (e.g. night time), because the
          number of distinct clients trying to communicate with the server
          could be lower than <command>max-unacked-clients</command>.
        </para>

        <para>In some cases it may be useful to disable the failure detection
        mechanism altogether, if the servers are located very close to each
        other and the network partitioning is unlikely, i.e. failure to
        respond to heartbeats is only possible when the partner is offline.
        In such cases, set the <command>max-unacked-clients</command> to 0.
        </para>

        <para>The <command>peers</command> parameter contains a list of servers
        within this HA setup. In this configuration it must contain at least
        one primary and one secondary server. It may also contain unlimited
        number of backup servers. In this example there is one backup server
        which receives lease updates from the active servers.</para>

        <para>There are the following parameters specified for each of the
        peers within this list:

        <itemizedlist mark="bullet">
          <listitem><para><command>name</command> - specifies unique name for
          the server.</para></listitem>

          <listitem><para><command>url</command> - specifies URL to be used to
          contact this server over the control channel. Other servers used this
          URL to send control commands to that server.</para></listitem>

          <listitem><para><command>role</command> - denotes the role of the
          server in the HA setup. The following roles are supported in the
          load balancing configuration: <command>primary</command>,
          <command>secondary</command> and <command>backup</command>.
          There must be exactly one primary and one secondary server in the
          load balancing setup.</para></listitem>

          <listitem><para><command>auto-failover</command> - a boolean value
          which denotes whether the server detecting a partner's failure should
          automatically start serving its clients.</para></listitem>

        </itemizedlist>
        </para>

        <para>In our example configuration, both active servers can allocate
        leases from the subnet "192.0.3.0/24". This subnet contains two
        address pools: "192.0.3.100 - 192.0.3.150" and "192.0.3.200 - 192.0.3.250",
        which are associated with HA servers scopes using client classification.
        When the <command>server1</command> processes a DHCP query it will use
        the first pool for the lease allocation. Conversely, when the
        <command>server2</command> is processing the DHCP query it will use the
        second pool. When any of the servers is in the <command>partner-down
        </command> state, it can serve leases from both pools and it will
        select the pool which is appropriate for the received query. In
        other words, if the query would normally be processed by the
        <command>server2</command>, but this server has crashed, the
        <command>server1</command> will allocate the lease from the pool of
        "192.0.3.200 - 192.0.3.250".
        </para>

      </section> <!-- end of ha-load-balancing-config -->

      <section xml:id="ha-hot-standby-config">
        <title>Hot Standby Configuration</title>
        <para>The following is the example configuration of the primary server
        in the hot standby configuration:
<screen>
{
"Dhcp4": {

    ...

    "hooks-libraries": [
        {
            "library": "/usr/lib/hooks/libdhcp_lease_cmds.so",
            "parameters": { }
        },
        {
            "library": "/usr/lib/hooks/libdhcp_ha.so",
            "parameters": {
                "high-availability": [ {
                    "this-server-name": "server1",
                    "mode": "hot-standby",
                    "heartbeat-delay": 10,
                    "max-response-delay": 10,
                    "max-ack-delay": 5,
                    "max-unacked-clients": 5,
                    "peers": [
                        {
                            "name": "server1",
                            "url": "http://192.168.56.33:8080/",
                            "role": "primary",
                            "auto-failover": true
                        },
                        {
                            "name": "server2",
                            "url": "http://192.168.56.66:8080/",
                            "role": "standby",
                            "auto-failover": true
                        },
                        {
                            "name": "server3",
                            "url": "http://192.168.56.99:8080/",
                            "role": "backup",
                            "auto-failover": false
                        }
                    ]
                } ]
            }
        }
    ],

    "subnet4": [
        {
            "subnet": "192.0.3.0/24",
            "pools": [
                {
                    "pool": "192.0.3.100 - 192.0.3.250",
                    "client-class": "ha_server1"
                }
            ],

            "option-data": [
                {
                    "name": "routers",
                    "data": "192.0.3.1"
                }
            ],

            "relay": { "ip-address": "10.1.2.3" }
        }
    ],

    ...

}

}
</screen>
        </para>

        <para>This configuration is very similar to the load balancing
        configuration described <xref linkend="ha-load-balancing-config"/>,
        with a few notable differences.</para>

        <para>The <command>mode</command> is now set to <command>hot-standby</command>,
        in which only one server is responding to the DHCP clients.
        If the primary server is online, the primary server is responding to
        all DHCP queries. The <command>standby</command> server takes over the
        entire DHCP traffic when it discovers that the primary is unavailable.
        </para>

        <para>In this mode, the non-primary active server is called
        <command>standby</command> and that's what the role of the second
        active server is set to.</para>

        <para>Finally, because there is always one server responding to the
        DHCP queries, there is only one scope <command>ha_server1</command>
        in use within pools definitions. In fact, the <command>client-class</command>
        parameter could be removed from this configuration without harm,
        because there are no conflicts in lease allocations by different
        servers as they do not allocate leases concurrently. The
        <command>client-class</command> is left in this example mostly for
        demonstration purposes, to highlight the differences between the
        hot standby and load balancing mode of operation.</para>
      </section> <!-- end of ha-hot-standby-config -->

      <section xml:id="ha-ctrl-agent-config">
        <title>Control Agent Configuration</title>
        <para>The <xref linkend="kea-ctrl-agent"/> describes in detail the
        Kea deamon which provides RESTful interface to control Kea servers.
        The same functionality is used by High Availability hook library to
        establish communication between the HA peers. Therefore, the HA
        library requires that Control Agent is started for each DHCP
        instance within HA setup. If the Control Agent is not started
        the peers will not be able to communicate with the particular DHCP
        server (even if the DHCP server itself is online) and may eventually
        consider this server to be offline.
        </para>

        <para>The following is the example configuration for the CA running
        on the same machine as the primary server. This configuration is
        valid for both load balancing and hot standby cases presented in
        previous sections.

<screen>
{
"Control-agent": {
    "http-host": "192.168.56.33",
    "http-port": 8080,

    "control-sockets": {
        "dhcp4": {
            "socket-type": "unix",
            "socket-name": "/tmp/kea-dhcp4-ctrl.sock"
        },
        "dhcp6": {
            "socket-type": "unix",
            "socket-name": "/tmp/kea-dhcp6-ctrl.sock"
        }
    }
}
}
</screen>
        </para>
      </section> <!-- end of ha-ctrl-agent-config -->

      <section xml:id="ha-control-commands">
        <title>Control Commands for High Availability</title>
        <para>Even though the HA hook library is designed to automatically
        resolve issues with DHCP service interruptions by redirecting the
        DHCP traffic to a surviving server and synchronizing the lease
        database when required, it may be useful for the administrator to
        have control over the server behavior. In particular, it may be
        useful be able to trigger lease database synchronization on demand.
        It may also be useful to manually set the HA scopes that are being
        served.</para>

        <para>Note that the backup server can sometimes be used to handle
        the DHCP traffic in case if both active servers are down. The backup
        servers do not perform failover function automatically. Hence, in
        order to use the backup server to respond to the DHCP queries,
        the server administrator must enable this function manually.
        </para>

        <para>The following sections describe commands supported by the
        HA hook library which are available for the administrator.
        </para>

        <section xml:id="ha-sync-command">
          <title>ha-sync command</title>
          <para>The <command>ha-sync</command> is issued to instruct the
          server to synchronize the local lease database with the
          selected peer. The database synchronization may be triggered for
          both active and backup server type. The <command>ha-sync</command>
          has the following structure (DHCPv4 server case):
<screen>
{
    "command": "ha-sync",
    "service": [ "dhcp4 "],
    "arguments": {
        "server-name": "server2",
        "max-period": 60
    }
}
</screen>
          </para>

          <para>
            When the server receives this command it first disables the
            DHCP service of the server from which it will be fetching leases,
            i.e. sends <command>dhcp-disable</command> command to that server.
            The <command>max-period</command> parameter specifies the maximum
            duration (in seconds) for which the DHCP service should be disabled.
            If the DHCP service is successfully disabled, the synchronizing
            server will fetch leases from the remote server by issuing the
            <command>lease4-get-all</command> command. When the lease database
            synchronization is complete, the synchronizing server sends the
            <command>dhcp-enable</command> to the peer to re-enable its
            DHCP service.
          </para>
        </section> <!-- ha-sync-command -->

        <section xml:id="ha-scopes-command">
          <title>ha-scopes command</title>
          <para>This command allows for modifying the HA scopes that the
          server is serving. Consult <xref linkend="ha-load-balancing-config"/>
          and <xref linkend="ha-hot-standby-config"/> to learn what scopes
          are available for different HA modes of operation. The
          <command>ha-scopes</command> command has the following structure
          (DHCPv4 server case):
<screen>
{
    "command": "ha-scopes",
    "service": [ "dhcp4 "],
    "arguments": {
        "scopes": [ "ha_server1", "ha_server2" ]
    }
}
</screen>
          </para>

          <para>This command configures the server to handle traffic from
          both <command>ha_server1</command> and <command>ha_server2</command>
          scopes. In order to disable all scopes specify an empty list:

<screen>
{
    "command": "ha-scopes",
    "service": [ "dhcp4 "],
    "arguments": {
        "scopes": [ ]
    }
}
</screen>
          </para>
        </section> <!-- ha-scopes-command -->

      </section> <!-- ha-control-commands -->

    </section> <!-- end of high-availability-library -->

    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="hooks-radius.xml"/>

    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="hooks-host-cache.xml"/>

  </section>

    <section xml:id="user-context">
      <title>User contexts</title>
      <para>Hook libraries can have their own configuration parameters. That is
      convenient if the parameter applies to the whole library. However,
      sometimes it is very useful if certain configuration entities are extended
      with additional configuration data. This is where the concept of user
      contexts comes in. A sysadmin can define an arbitrary set of data and
      attach it to Kea structures, as long as the data is specified as JSON map.
      In particular, it is possible to define fields that are integers, strings,
      boolean, lists and maps. It is possible to define nested structures of
      arbitrary complexity. Kea does not use that data on its own, simply stores
      and makes it available for the hook libraries.
      </para>
      <para>
        Another use case for user contexts may be storing comments and other
        information that will be retained by Kea. Regular comments are discarded
        when configuration is loaded, but user contexts are retained. This is
        useful if you want your comments to survive config-set, config-get
        operations for example.
      </para>
      <para>
        If user context is supported in a given context, the parser translates
        "comment" entries into user context with a "comment" entry. The pretty
        print of a configuration does the opposite operation and puts "comment"
        entries at the beginning of maps as it seems to be the common usage.
      </para>
      <para>
        As of Kea 1.3, the structures that allow user contexts are
        pools of all types (addresses and prefixes) and subnets. Kea
        1.4 extended user context support to the global scope, interfaces config,
        shared networks, subnets, client classes, option datas and definitions,
        host reservations, control socket, dhcp ddns, loggers and server id.
        These are supported in both DHCPv4 and DHCPv6 at the exception
        of server id which is DHCPv6 only.
      </para>
    </section>



   </chapter>
