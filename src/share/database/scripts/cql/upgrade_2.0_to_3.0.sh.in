#!/bin/sh

prefix=@prefix@
# Include utilities. Use installed version if available and
# use build version if it isn't.
if [ -e @datarootdir@/@PACKAGE_NAME@/scripts/admin-utils.sh ]; then
    . @datarootdir@/@PACKAGE_NAME@/scripts/admin-utils.sh
else
    . @abs_top_builddir@/src/bin/admin/admin-utils.sh
fi

# Need a path for temporary files created during upgrade data migration
# Use the state directory in the  install path directory if it exists, otherwise
# use the build tree
if [ -e @localstatedir@/@PACKAGE_NAME@ ]; then
    temp_file_dir="@localstatedir@/@PACKAGE_NAME@"
else
    temp_file_dir="@abs_top_builddir@/src/share/database/scripts/cql"
fi

cqlargs=$@

check_version() {
    version=$(cql_version $cqlargs)

    if [ "${version}" != "2.0" ]; then
        printf "This script upgrades 2.0 to 3.0. Reported version is %s. Skipping upgrade.\n" "${version}"
        exit 0 
    fi
}

update_schema() {
    cqlsh $cqlargs <<EOF
-- This line starts database upgrade to version 3.0

-- Add a column holding leases for user context.
ALTER TABLE lease4 ADD user_context text;
ALTER TABLE lease6 ADD user_context text;

-- -----------------------------------------------------
-- Table logs (it is used by forensic logging hook library)
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS logs (
    timeuuid timeuuid,  -- creation timeuuid, use dateOf() to get timestamp
    address varchar,    -- address or prefix
    log text,           -- the log itself
    PRIMARY KEY ((timeuuid))
);

-- Create search index for logs table
CREATE INDEX IF NOT EXISTS logsindex ON logs (address);

-- Add auth_key for storing keys for DHCPV6 reconfigure.
ALTER TABLE host_reservations ADD auth_key text;

-- Cql requires primary keys in the WHERE here.
DELETE FROM schema_version WHERE version=2;
INSERT INTO schema_version (version, minor) VALUES(3, 0);

-- This line concludes database upgrade to version 3.0
EOF

    if [ $? -ne 0 ]
    then
        echo Schema udpate FAILED!
        exit -1 
    fi 
}

clean_up() {
    # clean up the files
    if [ -e $export_file ]
    then
        rm $export_file
    fi

    if [ -e $update_file ]
    then
        rm $update_file
    fi
}

exit_now() {
    status=$1;shift
    explanation=$1

    clean_up
    if [ $status -eq 0 ]
    then
        echo "Data Migration SUCCESS! $explanation"
    else
        echo "Data Migration FAILURE! $explanation"
    fi

    exit $status
}

check_column() {
   local val="$1";shift
   local col="$1"
   local old_id="0"
   local new_id="-1"
   local comma=""

   if [ "$val" = "$old_id" ]
   then
        if [ ! -z "$update_cols" ]
        then
            comma=","
        fi

        update_cols="$update_cols$comma $col = $new_id"
   fi 
}

migrate_host_data() {
    export_file="$temp_file_dir/cql_export.csv"
    update_file="$temp_file_dir/cql_update.cql"

    clean_up

    # Fetch host_reservation data so we have primary key, plus subnet id values
    echo "Exporting host_reservation data to $export_file ..."
    query="COPY host_reservations \
        (id, host_ipv4_subnet_id, host_ipv6_subnet_id, option_subnet_id)\
        TO '$export_file'"

    cqlsh $cqlargs -e "$query"
    if [ $? -ne 0 ]
    then
        exit_now -1 "Cassandra export failed! Could not migrate data!"
    fi

    # Iterate through the exported data, accumulating update statements,
    # one for each reservation that needs updating.  We should have one
    # host per line.
    line_cnt=0;
    update_cnt=0;

    while read line
    do
        let line_cnt++;
        update_cols=""
        xIFS="$IFS"
        IFS=$'\r,' 
        i=1
        # Parse the column values
        for val in $line
        do
            case $i in
            1)
                host_id="$val"
                ;;
            2)
                check_column $val host_ipv4_subnet_id
                ;;
            3)
                check_column $val host_ipv6_subnet_id
                ;;
            4)
                check_column $val option_subnet_id
                ;;
            *)
                # We're going to assume that since any error is fatal
                exit_now -1 "Line# $line_cnt, too many values, wrong or corrupt file"
                ;;
            esac
            let i++
        done

        if [ $i -ne 5 ] 
        then
            # We're going to assume that since any error is fatal
            exit_now -1 "Line# $line_cnt, too few values, wrong or corrupt file"
        fi

        # If any of the current host's columns need to be replace, append an update for it
        if [ ! -z "$update_cols" ]
        then
            echo "update host_reservations set $update_cols where id = $host_id;" >> $update_file
            let update_cnt++
        fi

        IFS="$xIFS"
    done <  $export_file

    # If we didn't record any updates, then hey, we're good to go!
    if [ $update_cnt == 0 ]
    then
        exit_now 0 "Completedly successfully: No updates were needed"
    fi

    # We have at least one update in the update file, so submit it # to cqlsh.
    echo "$update_cnt update statements written to $update_file"
    echo "Running the updates..."
    cqlsh $cqlargs -f "$update_file"
    if [ $? -ne 0 ]
    then
        exit_now -1 "Cassandra updates failed"
        exit -1
    fi

    exit_now 0 "Updated $update_cnt of $line_cnt records"
}

check_version
update_schema
migrate_host_data
